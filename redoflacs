#!/usr/bin/env bash
# vim: ts=2:sts=2:sw=2:et:ft=sh:
#------------------------------------------------------------------------------
# NAME
#   redoflacs - BASH commandline FLAC compressor, verifier, organizer,
#               analyzer, and retagger
#
# FILE INFORMATION
#   Author:        Jaren Stangret <sirjaren@gmail.com>
#   Homepage:      https://github.com/sirjaren/redoflacs
#   Dependencies:  BASH >= 4.0
#
# DISTRIBUTION
#   The MIT License
#
#   Copyright 2018 Jaren Stangret
#
#   Permission is hereby granted, free of charge, to any person obtaining a
#   copy of this software and associated documentation files (the "Software"),
#   to deal in the Software without restriction, including without limitation
#   the rights to use, copy, modify, merge, publish, distribute, sublicense,
#   and/or sell copies of the Software, and to permit persons to whom the
#   Software is furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software.
#
#   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#   DEALINGS IN THE SOFTWARE.
#------------------------------------------------------------------------------

#################################  FUNCTIONS  #################################

_info() { printf     " ${green}*${reset} ${@}";  }  # Bold green message
_warn() { printf >&2 " ${yellow}*${reset} ${@}"; }  # Yellow message
_error(){ printf >&2 " ${red}*${reset} ${@}";    }  # Bold red message

_print_item_ok()   { printf "\033[${row}H${green}100%%${reset}";  }
_print_item_fail() { printf "\033[${row}H${red}fail${reset}";     }
_print_item_check(){ printf "\033[${row}H${yellow}chck${reset}";  }
_print_item_half() { printf "\033[${row}H${yellow} 50%%${reset}"; }
_print_item_skip() { printf "\033[${row}H${cyan}skip${reset}";    }

#
# Display help
#
_help()
{
  local REPLY

  IFS='' read -rd '' << HELP_EOF
Usage: redoflacs [operations] [options] [target] ...

Operations:
  -c, --compress
  -C, --compress-notest
  -t, --test
  -m, --md5check
  -a, --aucdtect
  -A, --aucdtect-spectrogram
  -e, --extract-artwork
  -p, --prune
  -g, --replaygain
  -G, --replaygain-noforce
  -r, --retag
  -l, --all
  -L, --reallyall

Options:
  -j[N], --jobs[=N]
  -n, --no-color
  -x, --no-extra-tags
  -o, --new-config
  -v, --version
  -h, --help

See redoflacs(1) for more information.
HELP_EOF

  printf '%s' "$REPLY"
}

#
# Display usage
#
_usage()
{
  printf >&2 ' Usage: redoflacs [operations] [options] [target] ...\n'
}

#
# Print out the correct operational message regarding a log file's existence
# and what infomration that log may contain.
#
# $1 determines the log file to use, as well as how many lines are printed out
# to correctly set the current row.  Possible values:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#
_message_log_exists()
{
  case "$1" in
    'aucdtect')
      _error 'Some FLAC files may be lossy sourced, please check:\n'
    ;;
    'md5check')
      _error 'The MD5 Signature is unset for some FLAC files or there were\n'
      _error 'issues with some of the FLAC files, please check:\n'
    ;;
    'compress'*|'test'|'replaygain_test'|'extract_images'|'prune')
      _error 'There were issues with some of the FLAC files,\n'
      _error 'please check:\n'
    ;;
    'replaygain')
      _error 'There were issues adding ReplayGain values,\n'
      _error 'please check:\n'
    ;;
    'retag')
      _error 'Some FLAC files have missing tags or there were\n'
      _error 'issues with some of the FLAC files, please check:\n'
    ;;
  esac

  # Print the bottom half of the message (uniform across all operations)
  _error "${cyan}${log_file}${reset}\n"
  _error 'for details.\n'
}

#
# Print out current operation message
#
# $1 determines which title message to print (if any).  Possible values:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#
# $2 is the number of processed items (iteration)
#
# $3 is conditionally called, and appears if the operation was interrupted:
#   Interrupted operation: $3 == 'interrupt'
#     Operation completed: $3 is NULL
#
_message()
{
  # Set up local variables
  declare message sub_message
  declare -i issues spacing

  # Print title message if $1 is not NULL
  if [[ -n "${1}" ]]; then
    case "${1}" in
      'aucdtect')       message='Validating with auCDtect'                ;;
      'md5check')       message='Check MD5 Signature'                     ;;
      'compress')       message="Level ${compression_level} Compression"  ;;
      'test')           message='Test FLACs'                              ;;
      'extract_images') message='Extracting Artwork'                      ;;
      'replaygain')     message='Applying ReplayGain'                     ;;
      'retag')          message='Retagging FLACs'                         ;;
      'prune')          message='Prune METADATA Blocks'                   ;;
    esac

    # Print title message, if applicable
    if [[ -n "${message}" && -z "$2" ]]; then
      printf "\033[$(_row)H ${green}*${reset} ${message}\n"
    fi

    # Print sub title message, if applicable
    if [[ -n "${sub_message}" && -z "$2" ]]; then
      printf "\033[$(_row);3H${green}>>${reset} ${sub_message}\n"
    fi
  fi

  # Update title/sub title message only if $2 is not NULL
  if [[ -n "${2}" ]]; then
    issues=$(_num_issues)  # Number of issues

    # Specify color according to operation status
    [[ "${3}" == 'interrupt' ]] && color="${cyan}" || color="${green}"

    # Verbage for singular/plural issues
    (( issues == 1 )) && issue_string='issue ' || issue_string='issues'

    if [[ -n "${sub_message}" ]]; then
      # Space between message and number of items proccessed
      spacing=$((44 - ${#sub_message} - ${#2} - ${#issues} - 14))

      # Sub title message
      printf "\033[2A   ${green}>>${reset} %s%${spacing}s${blue}[ ${color}%d ok${blue} | ${red}%d ${issue_string}${blue} ]${reset}\n" \
        "${sub_message}" '' "$2" "${issues}"
    else
      # Space between message and number of items proccessed
      spacing=$((46 - ${#message} - ${#2} - ${#issues} - 14))

      # Title message
      printf "\033[2A  ${green}*${reset} %s%${spacing}s${blue}[ ${color}%d ok${blue} | ${red}%d ${issue_string}${blue} ]${reset}\n" \
        "${message}" '' "$2" "${issues}"
    fi
  fi
}

#
# Update $operation_summary[@] with the current operation status
#
# $1 determines which operational index to update; possible values:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#
# $2 is the operational status, the values of which, can be:
#   Operation Completed       Operation Interrupted
#   Operation Did Not Run
#
_update_operation_status()
{
  case "${1}" in
    'aucdtect')           operation_summary['Validate with auCDtect']="${2}" ;;
    'md5check')           operation_summary['Check MD5 Signature']="${2}"    ;;
    'compress')           operation_summary['Compress FLACs']="${2}"         ;;
    'test')               operation_summary['Test FLACs']="${2}"             ;;
    'replaygain')         operation_summary['Applying ReplayGain']="${2}"    ;;
    'retag')              operation_summary['Retagging FLACs']="${2}"        ;;
    'extract_images')     operation_summary['Extracting Artwork']="${2}"     ;;
    'prune')              operation_summary['Prune METADATA Blocks']="${2}"  ;;
  esac
}

#
# Displays the currently processed item on a dedicated row within the
# terminal
#
# The filename is truncated if the length of the filename is greater
# than 80 characters or if greater than the width of the terminal if
# that terminal width is less than 80. This width is set by 'MAX_LENGTH'
#
# Filename truncation also occurs to allow the operation label and the
# total number of completed items to be displayed on the same row as the
# displayed item
#
# The structure of a displayed item:
#   '<percent> <basename>          <operation_label> <number_completed>'
#
# Which may look like:
#   '     06 - Some Amazing Song.flac                     Testing  6/20'
#
# This function does NOT create the display the percentage completed.
# That is handled later
#
# The file basename is left-aligned (leaving room for the percentage),
# while the operation label and total number of completed items are
# right-aligned
#
# An example of filename truncation:
#   '01 - This is a long name showing truncation.flac'
#
# This filename would be displayed during an operation as:
#   '     01 - This is a long name showing truncation.fla Testing  6/20'
#
# An example of how this would look with a percentage displayed:
#   ' 56% 06 - Some Amazing Song.flac                     Testing  6/20'
#
_print_item()
{
  local fmt truncated
  local basename="${item##*/}"
  local label="${1:+ ${1}}"  # Operation label (with leading space)

  # The total number of items out of the total number of items, used to
  # determine the maximum width these values can use, eg:
  #   ' 237/237'
  #
  # The leading space is intentional, to ensure a space is between the
  # item basename and this value
  local total=" ${#total_items[@]}/${#total_items[@]}"

  # This is the column position after the item basename is displayed.
  # This allows the operation label and total number of completed items
  # to be displayed after this column, effectively truncating the
  # current item if longer than this column position
  truncated="$((MAX_LENGTH - ${#total} - ${#label}))"

  # Belows builds the 'printf' format string
  fmt+=$"\033[${row};6H"              # Cursor row; 6 columns to right
  fmt+=$"\033[0K"                     # Erase line from cursor to right
  fmt+='%s'                           # Modifier; Current item basename
  fmt+=$"\033[${row};${truncated}H"   # Cursor row; Move to allow items
  fmt+=$"\033[0K"                     # Erase line from cursor to right
  fmt+="${magenta}%s"                 # Modifier; Operation label
  fmt+="${cyan}%${#total}s${reset}"   # Modifier; Items, right-aligned

  # Displays formatted, currently processed item
  printf "$fmt" "$basename" "$label" "${num}/${#total_items[@]}"
}

#
# Kill any children process and display the correct interrupt message when a
# user sends SIGINT during script execution.  Perform any cleanup, and check
# for the existence of a log file before exiting script.
#
# $1 determines which additional cleanup may need to be performed based off of
# operation interrupted, as well as whether the trap is invoked during a
# countdown interruption.  Possible values:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#   countdown
#
_trap_sigint()
{
  # Set up local variables
  declare    finished_items
  declare -a jobs_running=( $(jobs -rp) )  # Store running children processes

  _kill_jobs ${jobs_running[@]}            # Kill running children processes

  for (( i=1; i<=items_processed; i++)); do
    # Clear all the operation lines by moving up each line and clearing it,
    # until we are just below the operation's title message
    #--
    printf "\033[$(( post_row - i))H%${columns}s" ''
  done

  # Update title message, don't update if SIGINT was during a countdown
  if [[ "$1" != 'countdown' ]]; then
    # The number of completely finished (ok) items, minus any items
    # interrupted, minus items with issues
    finished_items="$(( iteration - ${#jobs_running[@]} - $(_num_issues) ))"
    _message "${operation}" "${finished_items}" 'interrupt'
  fi

  # Display extra newline if user invoked SIGINT during a countdown
  [[ "$1" == 'countdown' ]] && printf '\n'

  printf " ${green}*${reset} SIGINT received, generating summary...\n"

  case "${1}" in
    # Remove temporary script-created files
    #--
    'aucdtect'*) rm -f "${directory}"/**/*_redoflacs_"$$".wav  ;;
    'compress')  rm -f "${directory}"/**/*.tmp,fl-ac+en\'c     ;;
  esac

  # Update status for the current operation, but not if SIGINT was invoked
  # during a countdown
  if [[ "$1" != 'countdown' ]]; then
    _update_operation_status "${1}" 'Operation Interrupted'
  fi

  # Print out log exists to STDERR
  [[ -f "${log_file}" ]] && _message_log_exists "${1}"

  printf '\033[?25h'              # Restore the cursor
  printf '\033[?7h'               # Restore terminal wrapping
  rm -f "${job_fifo}"             # Remove temporary FIFO
  rm -f "${tmp_picture_blocks}"   # Remove temporary 'metaflac' block streams
  _summary                        # Display Summary Of Operations

  exit 130
}

#
# Display redoflacs version
#
_print_version() { printf 'Version %s\n' "${version}"; }

#
# Return metaflac version
#
_metaflac_version()
{
  # Metaflacs version (ie: '2' in 1.2.1)
  IFS='.' read -r _ metaflac_version _ < <(metaflac --version)
  printf '%s' "${metaflac_version}"
}

#
# Kill any children process (obtained via $@), hiding errors and suppressing
# the shell's notification of terminated jobs
#
_kill_jobs()
{
  for pid in $@ ; do
    kill ${pid} 2>/dev/null
    wait ${pid} 2>/dev/null
  done
}

#
# Return the current cursor's row position by sending the following control
# sequence to the controlling terminal:
#   CSI 6 n            # Query cursor position
#
# Which reports/returns the cursor position/terminal size as:
#   CSI height ; width R  # eg. '\033[80;23R'
#
_row()
{
  local row

  # Send CSI escape to (and read from) STDERR to not pollute STDIN
  IFS='[;' read -rsu2 -d'R' -p $'\033[6n' _ row _

  printf '%s' "$row"
}

#
# If necessary, scroll the terminal
#
_scroll_terminal()
{
  local row to_scroll

  # Obtain current row position
  row="$(_row)"

  # Default to scrolling the terminal based on the number of specified jobs
  to_scroll="$jobs"

  # Scrolling by number of items to process
  (( jobs > ${#total_items[@]} )) && to_scroll="${#total_items[@]}"

  # Only scroll if there are more items to display than lines available
  if (( --to_scroll > (lines - row) )); then
    printf "\033[$((to_scroll - (lines - row)))S"  # Scroll terminal
    printf "\033[$((lines - to_scroll))H"          # Cursor to scrolled start
  fi
}

#
# Force the creation of a new configuration file
#
_new_config()
{
  # Check if configuration file exists based of ${EUID}.  If it doesn't
  # exist, create one
  if (( EUID == 0 )); then
    # User is root
    #--
    # Configuration file location
    config_file='/etc/redoflacs.conf'

    # If there already is a configuration file, do not overwrite it
    if [[ -f "${config_file}" ]]; then
      config_file="/etc/_$$.redoflacs.conf"
    fi
  else
    # User is _NOT_ root
    #--
    # Configuration file location
    config_file="${HOME}/.config/redoflacs/config"

    # If there already is a configuration file, do not overwrite it
    if [[ -f "${config_file}" ]]; then
      config_file="${HOME}/.config/redoflacs/_$$.config"
    fi
  fi

  # Creates the (new) configuration file
  _create_config

  # Explain to user where to find the new configuration file
  _info 'A new configuration file has been created here:\n'
  _info "${cyan}${config_file}${reset}\n\n"

  _info "It's recommended to review the new configuration file\n"
  _info 'and transfer over any changes you made in your old\n'
  _info 'configuration file.\n\n'

  _info 'After making the changes (if any), rename the new\n'
  _info 'configuration file to your old configuration file\n'
  _info 'name.  Here is the command you could use:\n'

  if (( EUID == 0 )); then
    _info "${cyan}mv${reset} ${cyan}${config_file}${reset} ${cyan}/etc/redoflacs.conf${reset}\n"
  else
    _info "${cyan}mv${reset} ${cyan}${config_file}${reset} ${cyan}${HOME}/.config/redoflacs/config${reset}\n"
  fi
}

#
# Create a configuration file
#
_create_config()
{
  # Set up local array
  declare -a config

  # Don't expand variables when using heredoc
  mapfile -n0 -t config << "END_OF_CONFIG"
#
# redoflacs configuration
#
# Any line that is _NOT_ prepended with a '#' will be interpreted as an option
# (except for blank lines -- these are not interpreted)
#
# See redoflacs(1) for a detailed description of each parameter
#
# NOTE: The options listed below are shell syntax.  Interpolation can occur
# should weak (double) quotes be used.
#
#------------------------------------------------------------------------------
# TAGGING SECTION
#------------------------------------------------------------------------------
#
# List the tags to be kept in each FLAC file.  The default is listed below.
#
# Another common tag not added by default is ALBUMARTIST.  Uncomment
# ALBUMARTIST below to allow script to keep this tag.
#
# NOTE: Whitespace _IS_ allowed for the these tag fields, ie:
#   ALBUM ARTIST
#   CATALOG NUMBER ISBN
#
TITLE
ARTIST
#ALBUMARTIST
ALBUM
DISCNUMBER
DATE
TRACKNUMBER
TRACKTOTAL
GENRE

# The COMPRESSION tag is a custom tag to allow the script to determine which
# level of compression the FLAC file(s) has/have been compressed at.
COMPRESSION

# The RELEASETYPE tag is a custom tag the author of this script uses to
# catalog what kind of release the album is (ie, Full Length, EP, Demo, etc.).
RELEASETYPE

# The SOURCE tag is a custom tag the author of this script uses to catalog
# which source the album has derived from (ie, CD, Vinyl, Digital, etc.).
SOURCE

# The MASTERING tag is a custom tag the author of this script uses to catalog
# how the album has been mastered (ie, Lossless, or Lossy).
MASTERING

# The REPLAYGAIN tags below, are added by the '-g, --replaygain' or
# '-G, --replaygain-noforce' argument.  If you want to keep the ReplayGain
# tags, make sure you leave these here.
REPLAYGAIN_REFERENCE_LOUDNESS
REPLAYGAIN_TRACK_GAIN
REPLAYGAIN_TRACK_PEAK
REPLAYGAIN_ALBUM_GAIN
REPLAYGAIN_ALBUM_PEAK

#------------------------------------------------------------------------------
# OPTIONS
#------------------------------------------------------------------------------
#
# REMOVE ARTWORK:
#
# Set whether to remove embedded artwork within FLAC files.  By default, this
# script will remove any artwork it can find in the PICTURE block of a FLAC
# file.  Set 'remove_artwork' as 'true' to remove embedded artwork.  All other
# values are intepreted as 'false'.
remove_artwork='true'

#
# SET COMPRESSION:
#
# Set the type of COMPRESSION strength when compressing the FLAC files.
# Numbers range from '1-8', with '1' being the lowest compression and '8' being
# the highest compression.  The default is '8'.
compression_level='8'

#
# ERROR LOG DIRECTORY:
#
# Set where you want error logs to be placed.  By default, they are stored in
# the user's HOME directory.
error_log="${HOME}"

#
# AUCDTECT SKIP LOSSY:
#
# Set whether FLAC files should be skipped if the MASTERING tag is already set
# as 'Lossy' when analyzed with auCDtect.  Set 'skip_lossy' as 'true' to to
# skip FLAC files that have the tag: 'MASTERING=Lossy'.  All other values are
# intepreted as 'false'.
skip_lossy='true'

#
# SPECTROGRAM DIRECTORY:
#
# Set where created spectrogram images should be stored.  By default, they are
# stored in the same directory as the analyzed FLAC files.  Each image will
# have the same name as the tested FLAC file but with an integer suffix
# indicating the FLAC number (which was processed by the script) to allow for
# uniqueness.  The type of image created is PNG with the extension '.png'.
#
# All values for 'spectrogram_location' are interpreted as a directory.  If
# left blank, the default location will be used.
#
# An example of a user-defined location:
#    spectrogram_location="${HOME}/Spectrogram_Images"
#
# See redoflacs(1) for more information.
spectrogram_location=''

#
# EXTRACTED ARTWORK DIRECTORY:
#
# Set where the extracted artwork images should be stored.
#
# By  default, each extracted image will be placed in a subdirectory where the
# FLAC file is located.  The subdirectory housing the extracted artwork will
# have a similar name as the currently processed FLAC.  If a directory already
# exists, an integer is appended to the directory (to prevent overwriting and
# mixing files).  For example:
#
#    /path/to/01_file.flac          # FLAC file with embedded artwork
#    /path/to/01_file.flac_art/     # Directory housing artwork
#    /path/to/01_file.flac_art~1~/  # Directory '1' if above directory exists
#    /path/to/01_file.flac_art~2~/  # Directory '2' if above directory exists
#    /path/to/01_file.flac_art~N~/  # Directory 'N' if above directory exists
#
# All values for 'artwork_location' are interpreted as a directory.  If left
# blank, the default location will be used.
#
# If there is a user-defined location, the extracted images will be placed in a
# subdirectory in that location with a naming scheme similar to above:
#
#    artwork_location="${HOME}/artwork"    # User-defined configuration option
#
#    /path/to/01_file.flac                 # FLAC file with embedded artwork
#    ${HOME}/artwork/01_file.flac_art/     # Directory housing artwork
#    ${HOME}/artwork/01_file.flac_art~1~/  # If above directory exists
#
# See redoflacs(1) for more information.
artwork_location=''

#
# PREPEND TRACK NUMBER:
#
# Change whether the '-r, --retag' operation will re-tag singular track numbers
# and track totals from:
#    1, 2, 3, 4, 5, 6, 7, 8, 9
# to
#    01, 02, 03, 04, 05, 06, 07, 08, 09
#
# For example, if you had:
#    TRACKNUMBER=4
#     TRACKTOTAL=9
#
# You would end up with:
#    TRACKNUMBER=04
#     TRACKTOTAL=09
#
# This is enabled by setting 'prepend_zero' option as 'true'.  All other values
# are interpreted as 'false'.
prepend_zero='false'

#
# PRESERVE FILE MODIFICATION TIME:
#
# This is enabled by setting 'preserve_modtime' option as 'true'.  All other
# values are interpreted as 'false'
preserve_modtime='false'

# Version:4
END_OF_CONFIG

  # Write out configuration to either system-wide or local location
  printf '%s\n' "${config[@]}" > "${config_file}"
}

#
# Parse the user/system configuration file
#
_parse_config()
{
  local line
  local -ga tags_to_keep  # Global array used in _retag() function

  # Used to skip irrelevant configuration file lines
  local regex='^([[:space:]]+|#.*|)$'

  # Process the configuration file, storing all user-defined tags and
  # evaluate each configuration option
  while IFS=$'\n' read -r line; do
    # Skip empty lines, comment lines and lines with whitespace
    [[ "$line" =~ ^([[:space:]]+|#.*|)$  ]] && continue

    # Evaluate configuration file option
    if [[ "$line" == *'='* ]]; then
      eval "$line"
      continue
    fi

    # These are user-defined FLAC tags stored into a global array
    tags_to_keep+=( "${line^^}" )
  done < "$config_file"

  if [[ "$preserve_modtime" == 'true' ]]; then
    metaflac_extra_options='--preserve-modtime'
  fi
}

#
# Check current configuration, if the version in the script is newer warn user
# and display a countdown before starting script
#
_check_config_version()
{
  # Set up local variables/arrays
  declare    config_file  config_last_line  revision
  declare -a config_array

  # Check if configuration file exists based of ${EUID}.  If it doesn't
  # exist, create one
  if (( EUID == 0 )); then
    # User is root
    #--
    # Configuration file location
    config_file='/etc/redoflacs.conf'
  else
    # User is _NOT_ root
    #--
    # Configuration file location
    config_file="${HOME}/.config/redoflacs/config"
  fi

  # Load configuration file into an array
  mapfile -n0 -t config_array < "${config_file}"

  # Obtain only the last line of the config
  config_last_line="${config_array[@]: -1}"

  # Extract the revision number from the configuration file (new syntax format as
  # of redoflacs 0.30):
  IFS=':' read -r _ revision <<< "$config_last_line"

  # Check if ${revision} is an integer.  If not, display countdown and warn user
  # of new configuration file, else test if the user config revision is less than
  # the script config revision
  if [[ "${revision}" =~ ^[[:digit:]]+$ ]]; then
    if (( script_revision > revision )); then
      _countdown_config; printf '\n\n'
    fi
  else
    _countdown_config; printf '\n\n'
  fi
}

#
# Display countdown before retagging to allow user to quit script safely
#
_countdown_metadata()
{
  trap '_trap_sigint countdown' SIGINT  # Trap SIGINT to abort cleanly

  # Warning message
  _error "${yellow}CAUTION!${reset} These are the tag fields that will be kept\n"
  _error 'when re-tagging the selected files:\n'

  # Creates the listing of tags to be kept
  printf '     %s\n' "${tags_to_keep[@]}" >&2

  # Warning message about embedded coverart
  _error "By default, this script will ${cyan}REMOVE${reset} the legacy ${cyan}COVERART${reset} tag.\n"
  _error "Add the ${cyan}COVERART${reset} tag to the list of tags to be kept in the\n"
  _error "${cyan}TAGGING SECTION${reset} of the configuration file.\n\n"

  _error "Keep in mind, if the ${cyan}remove_artwork${reset} option is set to ${cyan}false${reset},\n"
  _error "embedded artwork in the ${cyan}PICTURE${reset} block will be kept when using\n"
  _error "the ${cyan}-p, --prune${reset} option as well.\n\n"

  _warn "Waiting ${red}10${reset} seconds before starting program...\n"
  _warn 'Ctrl+C (Control-C) to abort...\n'
  _info 'Starting in: '

  # 10 second countdown
  for count in {10..1}; do
    printf "${red}%d ${reset}" "$count"
    read -t1  # Sleep 1
  done

  printf '\n'  # Advance countdown to next line
}

#
# Displays countdown if a newer config is found to allow user to quit safely
#
_countdown_config()
{
  trap '_trap_sigint countdown' SIGINT  # Trap SIGINT to abort cleanly

  # Warning message
  _info 'There is a newer configuration file available!\n\n'

  _warn 'It is recommended you generate a new configuration\n'
  _warn 'file for use with this program.\n\n'

  _warn 'To generate a new configuration file, run:\n'
  _warn "${cyan}redoflacs --new-config${reset}\n\n"

  _warn 'The above command will _NOT_ overwrite your\n'
  _warn 'current configuration file.\n\n'

  _warn 'Waiting 10 seconds before starting program...\n'
  _warn 'Ctrl+C (Control-C) to abort...\n'
  _info 'Starting in: '

  # 10 second countdown
  for count in {10..1}; do
    printf "${red}%s ${reset}" "$count"
    read -t1  # Sleep 1
  done
}

#
# Clear job manager file descriptor (tied to FIFO) by closing and reopening
#
# $1 is the FIFO to tie the file descriptor to
#
_clear_jobs_fd()
{
  exec 3<&- 3>&-  # Close file descriptor
  rm -f "$1"      # Remove FIFO if it exists
  mkfifo "$1"     # Create FIFO
  exec 3<>"$1"    # Open file descriptor read/write
}

#
# Return an integer detailing the number of issues an operation may have had,
# returning '0', if no issues were found
#
_num_issues()
{
  declare ticks  # Set up local variable

  # Read in number of issue ticks, hiding missing file output
  { read -r ticks < "${issue_ticks}"; } 2>/dev/null
  printf '%d' "${#ticks}"  # Return number of ticks (0, if empty)
}

#
# Obtain and process the positional parameters invoked with the script
#
_process_positional_parameters()
{
  # Set up global variables
  declare -g all  reallyall  create_spectrogram  no_extra_tags  no_color \
    directory

  # Set up local variables/arrays
  declare -a args  long_args  short_args  non_args  converted_args
  declare    regex

  # If no arguments are made to the script show usage and help
  if (( ${#} == 0 )); then
    _help
    exit 1
  fi

  # If only one argument was called
  if (( ${#} == 1 )); then
    case "$1" in
      '--help'|'-h')        _help          ; exit 0 ;;
      '--version'|'-v')     _print_version ; exit 0 ;;
      '--new-config'|'-o')  _new_config    ; exit 0 ;;
      *)                    _usage         ; exit 1 ;;
    esac
  fi

  # If only two arguments were called
  if (( ${#} == 2 )); then
    case "$1" in
      # The number of jobs cannot be specified without an operation
      '--jobs='[[:digit:]]*' '|'-j'[[:digit:]]*' ')
        _usage
        _error "${cyan}${1}${reset} cannot used without an operation specified.\n"
        exit 1
      ;;
    esac
  fi

  for i in "${@}"; do
    # Separate long, short, and non arguments into separate arrays to be
    # converted into short arguments for 'getopts' to process correctly
    #--
    case "$i" in
      '--'*) long_args+=( "${i}" )   ;;
      '-'*)  short_args+=( "${i}" )  ;;
      *)     non_args+=( "${i}" )    ;;
    esac
  done

  # If there isn't a single non-argument (directory), exit
  if (( ${#non_args[@]} != 1 )); then
    _usage
    exit 1
  fi

  # Long arguments
  #--
  # If any were called, convert long arguments to short, allowing 'getopts' to
  # process them
  #--
  if [[ -n "${long_args[@]}" ]]; then
    for i in "${long_args[@]}"; do
      case "$i" in
        # These arguments are to be called by themselves, so quit
        '--version')              _usage; exit 1          ;;
        '--help')                 _usage; exit 1          ;;
        '--new-config')           _usage; exit 1          ;;

        # Send long arguments to array to process later
        '--aucdtect')             converted_args+=( -a )  ;;
        '--aucdtect-spectrogram') converted_args+=( -A )  ;;
        '--md5check')             converted_args+=( -m )  ;;
        '--compress')             converted_args+=( -c )  ;;
        '--compress-force')       converted_args+=( -C )  ;;
        '--test')                 converted_args+=( -t )  ;;
        '--replaygain')           converted_args+=( -g )  ;;
        '--replaygain-force')     converted_args+=( -G )  ;;
        '--retag')                converted_args+=( -r )  ;;
        '--extract-artwork')      converted_args+=( -e )  ;;
        '--prune')                converted_args+=( -p )  ;;
        '--all')                  converted_args+=( -l )  ;;
        '--reallyall')            converted_args+=( -L )  ;;
        '--no-color')             converted_args+=( -n )  ;;
        '--no-extra-tags')        converted_args+=( -x )  ;;

        '--jobs='*)
          # Enforce we have only digits after '--jobs=', and if so, set the
          # number of $jobs to its value, otherwise exit with a warning
          #--
          regex="[[:digit:]]+$"  # Regular expression
          if [[ "${i##*=}" =~ $regex ]] && (( ${i##*=} != 0 )); then
            jobs="${i##*=}"  # --jobs=11 -> 11
          else
            _usage
            _error "${cyan}--jobs${reset} requires a non-zero integer after it (eg. ${cyan}--jobs=11${reset}).\n"
            exit 1
          fi
        ;;

        # All other arguments are invalid
        *)  invalid_args+=( "${i}" )  ;;
      esac
    done
  fi

  # Short arguments
  #--
  # If any were called, add valid short arguments (using 'getopts') to the same
  # array as long arguments
  #--
  if [[ -n "${short_args[@]}" ]]; then
    while getopts ":j:LlcCtgGaAmeprnxhvo" args "${short_args[@]}"; do
      case "${args}" in
        # These arguments are to be called by themselves, so quit
        'v') _usage; exit 1          ;;
        'h') _usage; exit 1          ;;
        'o') _usage; exit 1          ;;

        # Send short arguments to array to process later
        'L') converted_args+=( -L )  ;;
        'a') converted_args+=( -a )  ;;
        'A') converted_args+=( -A )  ;;
        'm') converted_args+=( -m )  ;;
        'c') converted_args+=( -c )  ;;
        'C') converted_args+=( -C )  ;;
        't') converted_args+=( -t )  ;;
        'g') converted_args+=( -g )  ;;
        'G') converted_args+=( -G )  ;;
        'r') converted_args+=( -r )  ;;
        'e') converted_args+=( -e )  ;;
        'p') converted_args+=( -p )  ;;
        'l') converted_args+=( -l )  ;;
        'n') converted_args+=( -n )  ;;
        'x') converted_args+=( -x )  ;;

        'j')
          # Enforce we have only digits after '-j', and if so, set the
          # number of $jobs to its value, otherwise exit with a warning
          #--
          regex="[[:digit:]]+$"  # Regular expression
          if [[ "${OPTARG}" =~ $regex ]] && (( OPTARG != 0 )); then
            jobs="${OPTARG}"  # OPTARG is the argument after 'j' (j:)
          else
            _usage
            _error "${cyan}-j${reset} requires a non-zero integer after it (eg. ${cyan}-j11${reset}).\n"
            exit 1
          fi
        ;;
        ?)
          # Set invalid argument from getopts into array using
          # ${OPTARG}
          invalid_args+=( "-${OPTARG}" )
        ;;
      esac
    done
  fi

  # Display invalid arguments, if any
  if [[ -n "${invalid_args[@]}" ]]; then
    _usage
    _error 'Invalid option(s): '
    printf "${cyan}%s${reset}\n" "${invalid_args[*]}" >&2
    exit 1
  fi

  # Process converted arguments, setting each operation to run into an array
  #--
  # Run through the catchall arugments first
  for i in "${converted_args[@]}"; do
    case "${i}" in
      # These are the meta-arguments (do multiple operations)
      '-l')
        all='true'
        operations[1]='md5check'
        operations[2]='compress'
        operations[5]='replaygain'
        operations[7]='retag'
        operations[10]='prune'
      ;;
      '-L')
        reallyall='true'
        create_spectrogram='true'
        operations[0]='aucdtect'
        operations[1]='md5check'
        operations[2]='compress'
        operations[5]='replaygain'
        operations[7]='retag'
        operations[9]='extract_images'
        operations[10]='prune'
      ;;
    esac
  done

  # Run through the individual operations
  for i in "${converted_args[@]}"; do
    case "${i}" in
      # Process individual arguments
      '-a')
        if [[ "${create_spectrogram}" == 'true' || "${operations[0]}" == 'conflict' ]]; then
          operations[0]='conflict'  # If already set
        else
          operations[0]='aucdtect'
        fi
      ;;
      '-A')
        if [[ -n "${operations[0]}" && -z "${create_spectrogram}" ]] || [[ "${operations[0]}" == 'conflict' ]]; then
          operations[0]='conflict'  # If already set
        else
          create_spectrogram='true'
          operations[0]='aucdtect'
        fi
      ;;
      '-m') operations[1]='md5check'          ;;
      '-c') operations[2]='compress'          ;;
      '-C') operations[3]='compress'; force_compression='true' ;;
      '-t') operations[4]='test'              ;;
      '-g')
        if [[ "${operations[6]}" == 'replaygain' || "${operations[6]}" == 'conflict' ]]; then
          operations[6]='conflict'   # If already set
        else
          operations[5]='replaygain'
        fi
      ;;
      '-G')
        if [[ "${operations[6]}" == 'replaygain' || "${operations[6]}" == 'conflict' ]]; then
          operations[6]='conflict'   # If already set
        else
          operations[5]='replaygain'
        fi
        force_replaygain='true'
      ;;
      '-r')
        operations[7]='retag'
      ;;
      '-e')
        operations[9]='extract_images'
      ;;
      '-p') operations[10]='prune'            ;;
      '-n') no_color='true'                   ;;
      '-x') no_extra_tags='true'              ;;
    esac
  done

  args=( "${@}" )  # Store arguments into an array to process

  # Obtain the last element in $args[@], which is the directory to process
  #--
  # BASH 4.2 allows negative indices:
  #   directory="${args[-1]%/}"
  directory="${args[$(( ${#args[@]} - 1 ))]%/}"  # Remove ending slash (if any)
}

#
# Check for missing programs vital to this script
#
_check_missing_programs()
{
  # Set up local variables/arrays
  declare -a missing_commands

  # Add each command that's needed to an array to be displayed
  if ! type -P rm >/dev/null; then
    missing_commands+=( "   Missing ${cyan}rm${reset}        ->  Part of ${cyan}coreutils${reset}" )
  fi
  if ! type -P mkdir >/dev/null; then
    missing_commands+=( "   Missing ${cyan}mkdir${reset}     ->  Part of ${cyan}coreutils${reset}" )
  fi
  if ! type -P mkfifo >/dev/null; then
    missing_commands+=( "   Missing ${cyan}mkfifo${reset}    ->  Part of ${cyan}coreutils${reset}" )
  fi
  if ! type -P wc >/dev/null; then
    missing_commands+=( "   Missing ${cyan}wc${reset}        ->  Part of ${cyan}coreutils${reset}" )
  fi
  if ! type -P metaflac >/dev/null; then
    missing_commands+=( "   Missing ${cyan}metaflac${reset}  ->  Part of ${cyan}flac${reset}" )
  fi
  if ! type -P flac >/dev/null; then
    missing_commands+=( "   Missing ${cyan}flac${reset}      ->  Part of ${cyan}flac${reset}" )
  fi

  if [[ -n "${missing_commands[@]}" ]]; then
    # Display message that system is missing vital programs
    #--
    _error 'You seem to be missing one or more necessary programs\n'
    _error 'to run this script reliably.  Below shows the program(s)\n'
    _error 'missing, as well as where you can install them from:\n'
    for i in "${missing_commands[@]}"; do
      _warn "${i}\n"
    done
    exit 1
  fi

  # Optional binaries
  #--
  # Check for auCDtect if operation was called
  if [[ "${operations[0]}" == 'aucdtect' ]]; then
    # auCDtect cannot be found
    if ! type -P auCDtect >/dev/null; then
      _error "It appears ${cyan}auCDtect${reset} is not installed. Please verify you\n"
      _error "have this program installed and can be found in ${cyan}\$PATH${reset}\n"
      _error "\n"
      _error "A statically linked version of auCDtect can be found here\n"
      _error "  https://github.com/sirjaren/redoflacs/raw/binaries/auCDtect\n"
      exit 1
    fi
  fi

  # Check for SoX if auCDtect spectrograms were called
  if [[ "${create_spectrogram}" == 'true' ]]; then
    # SoX cannot be found
    if ! type -P sox >/dev/null; then
      _error "It appears ${cyan}SoX${reset} is not installed. Please verify you\n"
      _error "have this program installed and can be found in ${cyan}\$PATH${reset}\n"
      exit 1
    fi
  fi
}

#
# Check for any conflicting operations/arguments
#
_check_conflicting_operations()
{
  # '-l, --all' and '-L, --reallyall' cannot be called together
  if [[ "${all}" == 'true' && "${reallyall}" == 'true' ]]; then
    _error "Running both ${cyan}-l, --all${reset} and ${cyan}-L, --reallyall${reset} conflict!\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi

  # Store conflicting arguments if '-l, --all' or '-L, --reallyall' was called
  if [[ "${all}" == 'true' || "${reallyall}" == 'true' ]]; then
    # _compress_no_test()
    [[ -n "${operations[3]}" ]] && conflicting_args+=( '-C, --compress_notest' )

    case "${operations[6]}" in
      # _replaygain_apply()
      'replaygain_apply')
        conflicting_args+=( '-G, --replaygain-noforce' )
      ;;
    esac

    # Display conflicting arguments and exit, if there were any
    if [[ -n "${conflicting_args[@]}" ]]; then
      # '-l, --all'
      if [[ "${all}" == 'true' ]]; then
        _error "The below options conflict with ${cyan}-l, --all${reset}:\n"
      # '-L, --reallyall'
      elif [[ "${reallyall}" == 'true' ]]; then
        _error "The below options conflict with ${cyan}-L, --reallyall${reset}:\n"
      fi

      # Print each conflicting argument
      for i in "${conflicting_args[@]}"; do
        _error "  ${cyan}${i}${reset}\n"
      done

      _error '\nPlease remove incompatible options.\n'
      exit 1
    fi
  fi

  # _compress_verify() and _compress_no_test()
  if [[ -n "${operations[2]}" && -n "${operations[3]}" ]]; then
    _error "Running both ${cyan}-c, --compress${reset} and ${cyan}-C, --compress-notest${reset} conflict!\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi

  # _compress_no_test() and '-x, --no-extra-tags'
  if [[ -n "${operations[3]}" && "${no_extra_tags}" == 'true' ]]; then
    _error "Running both ${cyan}-C, --compress-notest${reset} and ${cyan}-x, --no_extra_tags${reset} conflict!\n\n"

    _error "${cyan}-x, --no_extra_tags${reset} invalidates the compression check, since each file\n"
    _error "seen to be missing the ${cyan}COMPRESSION${reset} tag is compressed, after which, the\n"
    _error "${cyan}COMPRESSION${reset} tag is NOT applied, leaving future executions to repeat this process.\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi

  # _compress_verify() and _test()
  if [[ -n "${operations[2]}" && -n "${operations[4]}" ]]; then
    _error "Running both ${cyan}-c, --compress${reset} and ${cyan}-t, --test${reset} conflict!\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi

  # _replaygain_force_apply and _replaygain_apply
  # 'conflict' is set during parameter handling if conflicts will ocurr
  if [[ "${operations[6]}" == 'conflict' ]]; then
    _error "Running both ${cyan}-g, --replaygain${reset} and ${cyan}-G, --replaygain-noforce${reset} conflict!\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi

  # _aucdtect and _aucdtect w/ spectrogram creation
  # 'conflict' is set during parameter handling if conflicts will ocurr
  if [[ "${operations[0]}" == 'conflict' ]]; then
    _error "Running both ${cyan}-a, --aucdtect${reset} and ${cyan}-A, --aucdtect-spectrogram${reset} conflict!\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi
}

#
# Display the summary of operations chart
#
_summary()
{
  # Set up local variables/arrays
  declare     operation  sub_message
  declare -a  operation_keys

  # Title
  printf "\033[$(_row);2H${blue}%s${reset}\n" \
  '---------------------------------------------------'
  printf '                Summary Of Operations\n'
  printf "${reset} ${blue}%s${reset}\n" \
  '-------------------------+-------------------------'

  # Correct order to display operational status to process
  operation_keys=(
    'Validate with auCDtect'
    'Check MD5 Signature'
    'Compress FLACs'
    'Test FLACs'
    'Applying ReplayGain'
    '>> Analyzing'
    '>> Re-Tagging'
    'Extracting Artwork'
    'Prune METADATA Blocks'
  )

  for operation in "${operation_keys[@]}"; do
    # Display each operational line with the status of that operation, if it
    # was called
    #--
    if [[ -n "${operation_summary[$operation]}" ]]; then
      # Check for sub messages, and apply additional formatting
      if [[ "${operation}" == '>> '* ]]; then
        if [[ "${operation}" == '>> Analyzing' ]]; then
          printf "${yellow}%25s ${blue}|${reset}\n" 'Retagging FLACs'
        fi

        printf -v sub_message '%25s' "${operation}"  # Store right aligned message

        # Color '>>' as yellow and message as magenta
        printf "${yellow}%s${magenta}%s ${blue}|${reset}" \
          "${sub_message%%>> *}>>" "${sub_message##*>>}"
      else
          printf "${yellow}%25s ${blue}|${reset}" "${operation}"
      fi

      # Colorize the operational status
      case "${operation_summary[$operation]}" in
        'Operation Completed')
          printf " ${green}%s${reset}\n" "${operation_summary[$operation]}"
        ;;
        'Operation Interrupted')
          printf " ${cyan}%s${reset}\n" "${operation_summary[$operation]}"
        ;;
        'Operation Did Not Run')
          printf " ${magenta}%s${reset}\n" "${operation_summary[$operation]}"
        ;;
        *'Issue'*)
          printf " ${red}%s${reset}\n" "${operation_summary[$operation]}"
        ;;
      esac
    fi
  done

  # Last line of chart
  printf " ${blue}%s${reset}\n" \
    '-------------------------+-------------------------'

  # Remove temporary FIFOs and files
  rm -f "${job_fifo}" "${tmp_aucdtect_fd}" "${issue_ticks}"

  printf '\033[?25h'   # Restore cursor
  printf '\033[?7h'    # Restore terminal wrapping
}

#
# Run a given operation with a specified number of jobs
#
# $1 is the operational function to run multiple jobs, which can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#
# Each name above is a function name, to be called as:
#   _<function_name>
#
# Examples:
#   _$1   # Eg: _aucdtect
#   _$1   # Eg: _extract_images
#
_run_parallel()
{
  local item
  local -i row num=0

  # Starting cursor row to display first item and operation progress
  row=$(($(_row) - 1))

  # Start as many operations as specified by the number of jobs
  for item in "${total_items[@]:0:${jobs}}"; do
    ((row++, num++))
    _$1 &
  done

  # Wait on operations
  (( ${#total_items[@]} <= jobs )) && wait

  # An operation is completed with an integer and newline sent to a FIFO.  The
  # integer is that row position an operation was on.  For each newline read
  # in, process another file/dir from $total_items[@]
  while read -r row; do
    (( num >= ${#total_items[@]} )) && break  # Stop, if no more FLACs
    item="${total_items[num++]}"              # Current item to process
    _$1 &
  done <&3  # Read from FIFO

  # Wait on operations
  wait
}

#
# Apply ReplayGain tags to each FLAC file in a given directory.
# Conditionally skip FLAC files if ReplayGain tags are already set. If
# there are any errors, they are logged
#
_replaygain()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output error_msg
  local -a error_log files

  # Used to look for error messages and store wanted values
  local regex="^(${item}/.*): (ERROR:.*)"

  _print_item 'Applying ReplayGain'

  # If a user chooses not to force apply ReplayGain tags, then each file
  # is checked to ensure all ReplayGain tags are available, skipping the
  # directory of files if all ReplayGain tags are already set
  #
  # NOTE:
  #   All errors are ignored here as they will be caught during
  #   application ReplayGain tags
  if [[ -z "$force_replaygain" ]]; then
    files=( "$item"/*$flac_extension )  # Used for number of files

    # Obtain ReplayGain tags from all files in the current directory
    mapfile -n0 -t replaygain_tags < <(
      metaflac 2>/dev/null \
        --show-tag='REPLAYGAIN_REFERENCE_LOUDNESS' \
        --show-tag='REPLAYGAIN_TRACK_GAIN' \
        --show-tag='REPLAYGAIN_TRACK_PEAK' \
        --show-tag='REPLAYGAIN_ALBUM_GAIN' \
        --show-tag='REPLAYGAIN_ALBUM_PEAK' \
        "${files[@]}"
    )

    # All ReplayGain tags are set, so this directory can be skipped
    #
    # The total number of ReplayGain tags found on all files in the
    # current directory must equal the total number of files found
    # multiplied by 5 (the number of ReplayGain tags added to each file)
    if (( ${#replaygain_tags[@]} == ${#files[@]} * 5 )); then
      _print_item_skip
      printf >&3 "$row\n"  # Send complete to _run_parallel()
      return
    fi
  fi

  _print_item_half  # Metaflac doesn't display a percentage complete

  # Since this operation applies to multiple files in a given directory,
  # all error messages (per file) is stored into an array, then logged
  # to a file
  #
  # Metaflac only displays error messages to STDERR, nothing to STDOUT
  while IFS=$'\n' read -r output; do
    # Any output is an error message
    if [[ "$output" =~ $regex ]]; then
      error_msg="${BASH_REMATCH[1]} [$operation] "  # Absolute filename

      # Error reading FLAC file (possibly fake), eg:
      #   ERROR: reading metadata, status = "FLAC__METADA ..."
      if [[ "${BASH_REMATCH[2]}" == *", status = "* ]]; then
        error_msg+="${BASH_REMATCH[2]%, status = *} "      # Error

      # Files with differing sample rates, or problems decoding, eg:
      #   ERROR: sample rate of 44100 Hz does not match ...
      #   ERROR: during analysis (decoding file)
      else
        error_msg+="${BASH_REMATCH[2]}"
      fi

      # All FLAC files are stored here to be logged
      error_log+=( "$error_msg" )
    fi
  done < <(
    metaflac 2>&1 \
      $metaflac_extra_options --add-replay-gain "$item"/*$flac_extension
  )

  # Log failures if there are any errors
  if [[ "${error_log[0]}" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s\n' "${error_log[@]}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    _print_item_ok
  fi

  # Send complete to _run_parallel()
  printf >&3 "$row\n"
}

#
# Compress FLAC files with user-defined compression, verifying
# integrity. Conditionally skip FLAC files if the 'COMPRESSION' tag
# exists for a given file and matches the compression level set in the
# user configuration file
#
_compress()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output previous error_msg warning_msg

  _print_item 'Compressing'

  # If a user chooses not to force compression, then each file is
  # checked for a 'COMPRESSION' tag that matches the compression level
  # set in the user configuration. If the 'COMPRESSION' tag exists and
  # matches what is set in the configuration, then this file is skipped
  #
  # NOTE:
  #   All errors are ignored here as they will be caught during
  #   compression
  if [[ -z "$force_compression" ]]; then
    file_compression="$(metaflac 2>/dev/null --show-tag='COMPRESSION' "$item")"

    # 'compression_level' is obtained from the configuration file, in
    # form of 'COMPRESSION=<value>'
    if (( ${file_compression##*=} == compression_level )); then
      _print_item_skip
      printf >&3 "$row\n"  # Send complete to _run_parallel()
      return
    fi
  fi

  # As indicated by '[FIRST]', '[SECOND]', '[THIRD]', '[FOURTH]', and
  # '[LAST]', this is the order each of the statements will evaluate to
  # 'true'.  '[FIRST]' may never evaluate to 'true' (if the FLAC file
  # fails to decode
  while IFS=$'\n' read -rd ' ' output; do
    # [LAST] Store error message
    if [[ "$error_msg" && -n "$output" ]]; then
      # End of error message
      [[ "$output" == 'state' || "$output" == '"flac"' ]] && break
      error_msg+=" $output"
      continue
    fi

    # [FOURTH] An error occurred, storing first word
    if [[ "$output" == 'ERROR:' && "$previous" == *"${base}:" ]]; then
      error_msg="$output"
      continue
    fi

    # [THIRD] Store rest of warning message
    if [[ "$warning_msg" && -n "$output" ]]; then
      # Stop if there is an error message and build that separately
      [[ "$output" == *'ERROR:' ]] && error_msg='ERROR:' && continue
      warning_msg+=" $output"
      continue
    fi

    # [SECOND] A warning occurred, storing first word
    #
    # NOTE:
    #   Due to 'read' using a space a delimiter, the WARNING message may
    #   have preceding text (word + newline)
    if [[ "$output" == *'WARNING:' ]]; then
      warning_msg='WARNING:'
      continue
    fi

    # [FIRST] FLAC compression percentage complete
    if [[ "$output" == *[[:digit:]]% ]]; then
      output="${output//$'\b'}"  # Remove all backspace characters

      # Remove beginning ratio string (from backspace characters)
      printf "\033[${row}H${yellow}%4s$reset" "${output#ratio=?.???}"
    fi

    # Used to validate previous output is an error and not a filename
    previous="$output"
  done < <(flac 2>&1 -f -"$compression_level" -V "$item")

  # Add warning message to error message for logging
  [[ "$warning_msg" ]] && error_msg="$warning_msg|$error_msg"

  # Log failures if there are any warnings and/or errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    error_msg="${error_msg%,}"          # Strip possible trailing comma
    error_msg="${error_msg/$'\n'Type}"  # Strip possible multiline error
    printf >> "$log_file" '%s [%s] %s\n' "$item" "$operation" "$error_msg"
    printf >> "$issue_ticks" '.'        # Add one tick to total issues

    # Send complete to _run_parallel()
    printf >&3 "$row\n"
    return
  fi

  # Add a 'COMPRESSION' tag to the current FLAC file, to indicate which
  # compression level was used when compressing
  #
  # NOTE:
  #   Errors are ignored as the FLAC file was verified during encoding
  metaflac 2>/dev/null \
    $metaflac_extra_options --set-tag="COMPRESSION=$compression_level" "$item"
  _print_item_ok

  # Send complete to _run_parallel()
  printf >&3 "$row\n"
}

#
# Tests current FLAC file integrity, reading all output, displaying the
# current percentage complete. If there is an error that error is logged
#
_test()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output previous error_msg

  # Basename of FLAC, splitting on whitespace since the 'read' below
  # splits on whitespace
  local base="${item##*[ /]}"

  _print_item 'Testing'

  # As indicated by '[FIRST]', '[SECOND]', and '[LAST]', this is the
  # order each of the statements will evaluate to 'true'. '[FIRST]' may
  # never evaluate to 'true' (if the FLAC file fails to decode)
  while IFS=$'\n' read -rd ' ' output; do
    # [LAST] Store error message
    if [[ "$error_msg" && -n "$output" ]]; then
      [[ "$output" == 'state' ]] && break  # End of error message
      error_msg+=" $output"
      continue
    fi

    # [SECOND] An error occurred, storing first word
    if [[ "$output" == 'ERROR' && "$previous" == *"${base}:" ]]; then
      error_msg="$output"
      continue
    fi

    # [FIRST] FLAC testing percentage complete
    if [[ "$output" == *[[:digit:]]% ]]; then
      printf "\033[${row}H${yellow}%4s$reset" "$output"
    fi

    # Used to validate previous output is an error and not a filename
    previous="$output"
  done < <(flac 2>&1 -t "$item")

  # Log failures if there are any errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [%s] %s\n' "$item" "$operation" "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    _print_item_ok
  fi

  # Send complete to _run_parallel()
  printf >&3 "$row\n"
}

#
# Test FLAC validity with auCDtect
#
# NOTE:
#   While not officially supported, should a user have a dynamically
#   linked auCDtect binary, 'MALLOC_CHECK_' will to be set to '0', eg:
#
#     MALLOC_CHECK_='0' auCDtect <rest_of_options>
#
_aucdtect()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local item_wav output previous error_msg aucdtect_stdout aucdtect_stderr \
    spectrogram
  local -a bits_mastering

  # Used to look for error messages and file status in auCDtect which is
  # captured via STDOUT
  #
  # Example STDOUT from auCDtect (error message):
  #   auCDtect: CD records authenticity detector, version 0.8
  #   Copyright (c) 2004 Oleg Berngardt. All rights reserved.
  #   Copyright (c) 2004 Alexander Djourik. All rights reserved.
  #   error:  file format     is not supported
  #
  # Example STDOUT from auCDtect (file status):
  #   auCDtect: CD records authenticity detector, version 0.8
  #   Copyright (c) 2004 Oleg Berngardt. All rights reserved.
  #   Copyright (c) 2004 Alexander Djourik. All rights reserved.
  #   ------------------------------------------------------------
  #   Processing file:        [01 - The Manifesto.wav]
  #
  #   ------------------------------------------------------------
  #   This track looks like CDDA with probability 85%
  #
  # Example regex capture groups obtained:
  #
  # Error messages:
  #   error:  can     not     open file <WAV_FILE>
  #   error:  file format     is not supported
  #
  # Successful operations:
  #   This track looks like CDDA with probability 100%
  #   This track looks like CDDA with probability 49%
  #   This track looks like MPEG with probability 100%
  #   This track looks like MPEG with probability 92%
  #   Could not qualify the source of this track.
  local regex=$'(error:.*)|Processing file.*--------.*\n(.*)$'

  _print_item 'auCDtect'

  # Get the bit depth and MASTERING tag of a FLAC file. Errors will be
  # caught during decoding. Indices are:
  #   bits_mastering[0] = bit depth (eg: 16)
  #   bits_mastering[1] = MASTERING tag and value (eg: MASTERING=Lossy)
  mapfile -n2 -t bits_mastering < <(
    metaflac 2>/dev/null --show-bps --show-tag='MASTERING' "$item"
  )

  # auCDtect does not support a bit depth greater than 16 (CD quality
  # only), skipping file
  #
  # NOTE:
  #   A default value of 0 is specified in the event the bit depth could
  #   not be obtained. Errors will be caught during decoding
  if (( ${bits_mastering[0]:-0} > 16 )); then
    _print_item_skip
    printf >&3 "$row\n"  # Send complete to _run_parallel()
    return
  fi

  # Skip FLAC file if MASTERING=Lossy is set and the 'skip_lossy'
  # configuration option is 'true'
  if [[
    "${bits_mastering[1]#*=}" == 'Lossy'
    && "$skip_lossy" == 'true'
  ]]; then
    _print_item_skip
    printf >&3 "$row\n"  # Send complete to _run_parallel()
    return
  fi

  # The WAV file to be created from current FLAC file
  item_wav="${item%${flac_extension}}_redoflacs_$$.wav"

  _print_item 'Decoding'

  # As indicated by '[FIRST]', '[SECOND]', and '[LAST]', this is the
  # order each of the statements will evaluate to 'true'. '[FIRST]' may
  # never evaluate to 'true' (if the FLAC file fails to decode)
  while IFS=$'\n' read -rd ' ' output; do
    # [LAST] Store error message
    if [[ "$error_msg" && -n "$output" ]]; then
      [[ "$output" == 'state' ]] && break  # End of error message
      error_msg+=" $output"
      continue
    fi

    # [SECOND] An error occurred, storing first word
    if [[ "$output" == 'ERROR' && "$previous" == *"${base}:" ]]; then
      error_msg="$output"
      continue
    fi

    # [FIRST] FLAC decoding percentage complete
    if [[ "$output" == *[[:digit:]]% ]]; then
      output="${output//$'\b'}"  # Remove all backspace characters

      # Remove beginning 'complete' string (from backspace characters)
      printf "\033[${row}H${yellow}%4s$reset" "${output#complete}"
    fi

    # Used to validate previous output is an error and not a filename
    previous="$output"
  done < <(flac 2>&1 -d "$item" -o "$item_wav")

  # Log failures if there are any errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [%s] %s\n' "$item" 'auCDtect' "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  else
    _print_item_ok
  fi

  # Runs auCDtect with medium accuracy setting (for speed):
  #   STDOUT: auCDtect STDOUT captured to be parsed
  #   STDERR: auCDtect progress percentage completed sent to FD4
  _print_item 'auCDtect:Fast'
  exec 4>&1
  aucdtect_stdout="$(
    MALLOC_CHECK_='0' auCDtect -m20 "$item_wav" 2> >(
      while IFS=$'\n' read -rd $'\r' aucdtect_stderr; do
        aucdtect_stderr="${aucdtect_stderr##*[}"
        printf >&4 "\033[${row}H${yellow}%4s$reset" "${aucdtect_stderr%]}"
      done
    )
  )"
  exec 4>&-

  # Looks for error messages and file status from auCDtect
  #   BASH_REMATCH[1]: auCDtect error messages
  #   BASH_REMATCH[2]: auCDtect file status
  [[ "$aucdtect_stdout" =~ $regex ]]

  # Log failures if there are any errors
  if [[ "${BASH_REMATCH[1]}" ]]; then
    _print_item_fail
    printf >> "$log_file" \
      '%s [%s] %s\n' "$item" 'auCDtect' "${BASH_REMATCH[1]}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
    rm "$item_wav"                # Remove temporary WAV file
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return

  # auCDtect reports CDDA of 100%, continue with next item
  elif [[ "${BASH_REMATCH[2]}" == *'CDDA'*'100%'* ]]; then
    _print_item_ok
    rm "$item_wav"                # Remove temporary WAV file
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  fi

  # Current item is not CDDA of 100%, auCDtect is run with highest
  # accuracy setting:
  #   STDOUT: auCDtect STDOUT captured to be parsed
  #   STDERR: auCDtect progress percentage completed sent to FD4
  _print_item 'auCDtect:Slow'
  exec 4>&1
  aucdtect_stdout="$(
    MALLOC_CHECK_='0' auCDtect -m0 "$item_wav" 2> >(
      while IFS=$'\n' read -rd $'\r' aucdtect_stderr; do
        aucdtect_stderr="${aucdtect_stderr##*[}"
        printf >&4 "\033[${row}H${yellow}%4s$reset" "${aucdtect_stderr%]}"
      done
    )
  )"
  exec 4>&-

  # Looks for error messages and file status from auCDtect
  #   BASH_REMATCH[1]: auCDtect error messages
  #   BASH_REMATCH[2]: auCDtect file status
  [[ "$aucdtect_stdout" =~ $regex ]]

  # Log failures if there are any errors
  if [[ "${BASH_REMATCH[1]}" ]]; then
    _print_item_fail
    printf >> "$log_file" \
      '%s [%s] %s\n' "$item" 'auCDtect' "${BASH_REMATCH[1]}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
    rm "$item_wav"                # Remove temporary WAV file
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  fi

  # auCDtect reports CDDA of 100%, continue with next item
  if [[ "${BASH_REMATCH[2]}" == *'CDDA'*'100%'* ]]; then
    _print_item_ok
    rm "$item_wav"                # Remove temporary WAV file
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  fi

  # Log failure if not CDDA with 100% and no spectrogram is requested
  if [[
    "${BASH_REMATCH[2]}" != *'CDDA'*'100%'*
    && "$create_spectrogram" != 'true'
  ]]; then
    _print_item_check
    printf >> "$log_file" \
      '%s [%s] %s\n' "$item" 'auCDtect' "${BASH_REMATCH[2]}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
    rm "$item_wav"                # Remove temporary WAV file
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  fi

  # User requested a spectrogram, SoX is run to generate a spectrogram
  # in the location as the current item or a user-defined location
  _print_item 'Spectrogram'

  # Default location for spectrogram, eg:
  #   /path/to/file.flac.spec.png.0
  #
  # User defined (eg: /tmp):
  #   /user/configured/path/to/file.flac.spec.png.0
  spectrogram="${spectrogram_location:-${item%/*}}/${item##*/}.spec.png.0"

  # Ensure we don't clobber the spectrogram, eg:
  #   /path/to/file.flac.spec.png.0 ->
  #   /path/to/file.flac.spec.png.1 ->
  until [[ ! -f "$spectrogram" ]]; do
    spectrogram="${spectrogram%.*}.$((${spectrogram##*.} + 1))"
  done

  # SoX display progress percentage on STDERR as well as any error
  # messages. Example output:
  #
  # Error messages:
  #   sox FAIL formats: can't open input file `file.wav': WAVE: RIF<...>
  #   sox FAIL formats: can't open input file `file.flacd': No such<...>
  #
  # NOTE:
  #  The '-n1000' is to force 'read' to grab the SoX error if there are
  #  any error messages, otherwise the percentage complete is read
  while IFS=$'\n' read -rd '%' -n1000 output; do
    # Strip from leading string until percentage complete
    output="${output##*In:}"

    # Strip floating point from output
    printf "\033[${row}H${yellow}%4s${reset}" "${output%%.*}%"
  done < <(
    sox 2>&1 "$item" -S -n spectrogram -o "$spectrogram" -t "$item" \
      -c '' -p 1 -z 90 -Z 0 -q 249 -w Hann -x 1800 -y 513
  )

  # Log failures if there are any errors from SoX
  if [[ "$output" == 'sox FAIL'* ]]; then
    _print_item_fail
    printf >> "$log_file" \
      '%s [%s] %s\n' "$item" 'auCDtect:Spectrogram' "$output"

  # Log auCDtect status for item as well as generated spectrogram
  else
    _print_item_check
    printf >> "$log_file" \
      '%s [%s] %s (%s)\n' \
      "$item" 'auCDtect:Spectrogram' "${BASH_REMATCH[2]}" "$spectrogram"
  fi

  printf >> "$issue_ticks" '.'  # Add one tick to total issues
  rm "$item_wav"                # Remove temporary WAV file
  printf >&3 "$row\n"           # Send complete to _run_parallel()
}

#
# Check for a valid MD5 checksum in FLAC file
#
_md5check()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output error_msg md5sum

  _print_item 'Verifying MD5'

  # Metaflac will display the MD5 checksum or an error (on one line).
  # These values are captured and logged, appropriately
  while IFS=$'\n' read -r output; do
    # Error reading FLAC file (possibly fake), eg:
    #   fake/fake.flac: ERROR: reading metadata, status = "FLAC ..."
    if [[ "$output" == *'ERROR'* ]]; then
      error_msg="${output%, status = *}"      # Strip status
      error_msg="ERROR${error_msg#*: ERROR}"  # Strip filename
      break                                   # Stop reading lines
    fi

    # This is the MD5 checksum
    md5sum="$output"
  done < <(metaflac 2>&1 --show-md5sum "$item")

  # Log failures if there are any errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [%s] %s\n' "$item" "$operation" "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues

  # Possible valid FLAC, but MD5 signature is unset in STREAMINFO block
  elif [[ "$md5sum" == '00000000000000000000000000000000' ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [%s] %s\n' "$item" "$operation" \
      'ERROR: Unset MD5 signature (00000000000000000000000000000000)'
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    _print_item_ok
  fi

  # Send complete to _run_parallel()
  printf >&3 "$row\n"
}

#
# Looks for the tags specified in the configuration file, stripping all
# other tags from a given FLAC file, and logging any tags which are
# missing
#
# Process substitution when extracting tags is used to ensure trailing
# newlines are not stripped
#
_retag()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output error_msg line extracted_tag key empty_tag tag missing_tags_str
  local -i index='-1'
  local -a missing_tags found_tags tags

  _print_item 'Retagging'

  # Extracts the first tag from the list of tags to keep and does error
  # handling on this operation. Other extracted tags are processeed in
  # the following loop after the error handling
  #
  # Metaflac will display errors on one line. These are handled first
  # with the tag value obtained last (if no failures)
  while IFS=$'\n' read -r output; do
    # Error reading FLAC file (possibly fake), eg:
    #   fake/fake.flac: ERROR: reading metadata, status = "FLAC ..."
    if [[ "$output" == *'ERROR'* ]]; then
      error_msg="${output%, status = *}"      # Strip status
      error_msg="ERROR${error_msg#*: ERROR}"  # Strip filename
      break                                   # Stop reading lines
    fi

    # This is the extracted tag (could be empty or multiple lines)
    if [[ "$extracted_tag" ]]; then
      extracted_tag+=$'\n'"$output"
    else
      extracted_tag+="$output"
    fi
  done < <(metaflac 2>&1 --show-tag="${tags_to_keep[0]}" "$item")

  # Log failures if there are any errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [%s] %s\n' "$item" "$operation" "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues

    # Send complete to _run_parallel()
    printf >&3 "$row\n"
    return
  fi

  # Look for each of the tags to keep in the current FLAC flac,
  # separating each of the tags as separate indices in an array. If
  # there are any missing tags, these are stored as well
  for key in "${!tags_to_keep[@]}"; do
    # The first tag (index=0) was already obtained during error checking
    if (( key != 0 )); then
      IFS='' read -rd '' extracted_tag < <(
        metaflac 2>&1 --show-tag="${tags_to_keep[key]}" "$item"
      )

      # Strips trailing newline due to the process substitution
      # preserving trailing newlines
      extracted_tag="${extracted_tag%$'\n'}"
    fi

    # The tag doesn't exist in the current item
    if [[ -z "$extracted_tag" ]]; then
      missing_tags+=( "${tags_to_keep[key]}" )
      continue
    fi

    # Processes the extracted tag, looking for multiple tags of the same
    # type as well and handling multiple line values for a given tag
    # value. For any valid tags, each are stored as a separate index in
    # an array
    #
    # For any stored tag, the tag field is converted to uppercase and
    # the tag values are normalized (whitespace, zero-prefixed, etc)
    while IFS=$'\n' read -r line; do
      # Tag exists but the value is empty. This may be a missing tag
      if [[ "${line^^}" == "${tags_to_keep[key]^^}=" ]]; then
        # If a previous line was an empty tag field, this means the
        # previous tag was, in fact, empty
        [[ "$empty_tag" ]] && missing_tags+=( "$empty_tag" )

        # Sets the tag field as empty and is used to check any
        # additional lines which may be part of this tag
        empty_tag="${tags_to_keep[key]^^}"
        continue

      # Tag exists and has a value (first line value only)
      elif [[ "${line^^}" == "${tags_to_keep[key]^^}="* ]]; then
        # Strip leading/trailing whitespace
        IFS=$' \t\n' read -r line <<< "${line#*=}"

        # Convert TRACKNUMBER and TRACKTOTAL to zero-prefixed numbers if
        # the 'prepend_zero' configuration option is 'true'
        if [[
          (
            "${tags_to_keep[key]}" == 'TRACKNUMBER'
            || "${tags_to_keep[key]}" == 'TRACKTOTAL'
          )
          && "$prepend_zero" == 'true'
        ]]; then
          # Only modify value if the value is an integer
          if [[ "$line" =~ ^[[:digit:]]+$ ]]; then
            printf -v line '%02d' $((10#$line))
          fi
        fi

        # Ensure tag field is uppercase and array index, incremented.
        # The index starts at -1, so is pre-incremented to 0 before
        # setting a value
        found_tags[++index]="${tags_to_keep[key]^^}=$line"
        continue
      fi

      # Strip leading/trailing whitespace
      IFS=$' \t\n' read -r line <<< "$line"

      # If this variable is set, it means the previous line was an empty
      # tag field but since this point is reached, the current line is a
      # part of the tag so the previous line is a valid tag. The tag is
      # considered NOT empty and is saved with this line as part of the
      # tag's value. An example tag where this could happen:
      #
      #    LYRICS=
      #
      #    This is a line for the above 'LYRICS' tag field.
      #    This is another line which is a part of the same tag.
      #
      # The first line (LYRICS=) is originally considered an empty tag,
      # but the following lines are processed and added to the tag
      # making this tag valid and non-empty
      if [[ "$empty_tag" ]]; then
        found_tags[++index]="${empty_tag}="$'\n'"$line"
        empty_tag='' # Reset as the tag is considered valid
      else
        # Another value (separate line) for the current tag field
        found_tags[index]+=$'\n'"${line}"
      fi
    done <<< "$extracted_tag"
  done

  # Runs through the missing tags and only stores the tag as missing if
  # there are no other tags found which match the tag field. This could
  # happen, if there are multiple tags of the same tag field and some
  # are empty, but at least one is valid, eg:
  #
  #   DATE=
  #   DATE=
  #   DATE=2001
  #
  # The DATE tag is considered missing, but when processed below, would
  # be considered found and valid (the other empty DATE tags will be
  # removed)
  for tag in "${!missing_tags[@]}"; do
    # Looks through all the valid and normalized tags found
    for valid_tag in "${found_tags[@]}"; do
      # Matched a tag and value for a missing tag, no longer missing
      if [[ "$valid_tag" == "${missing_tags[tag]}="* ]]; then
        unset -v missing_tags[tag]
        break
      fi
    done
  done

  # Removes all tags from the current FLAC file and sets each found tag
  # all in one operation. A single operation prevents SIGINT from
  # leaving the current FLAC file without any tags
  metaflac >/dev/null 2>&1 $metaflac_extra_options \
    --remove-all-tags "${found_tags[@]/#/--set-tag=}" "$item"

  # Logs missing tags, if any were found
  if [[ "${missing_tags[@]}" ]]; then
    _print_item_check

    # Generates a comma-separated list of missing tags to be logged.
    # Ensures spaces in tag fields are properly handled
    for tag in "${missing_tags[@]}"; do
      if [[ "$missing_tags_str" ]]; then
        missing_tags_str+=", $tag"
      else
        missing_tags_str+="$tag"
      fi
    done

    printf >> "$log_file" \
      '%s [retag] Missing tags: %s\n' "$item" "$missing_tags_str"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    _print_item_ok
  fi

  # Send complete to _run_parallel()
  printf >&3  "$row\n"
}

#
# Extact embedded artwork from a given FLAC
#
_extract_images()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local -a artwork
  local error_msg block_id art_id art_description mime img
  local blocks="/tmp/redoflacs_picture_blocks.$BASHPID"

  # Ensure we don't clobber the temporary PICTURE blocks file, eg:
  #   /tmp/redoflacs_picture_blocks.0 -> /tmp/redoflacs_picture_blocks.1
  until [[ ! -f "$blocks" ]]; do
    blocks="${blocks%.*}.$((${blocks##*.} + 1))"
  done

  _print_item 'Extracting Images'

  # Retrieve PICTURE blocks from current item, storing to a temporary file
  error_msg="$(metaflac 2>&1 >"$blocks" --list --block-type=PICTURE "$item")"

  # Log FLAC failure
  if [[ -n "$error_msg" ]]; then
    error_msg="${error_msg%, status = *}"       # Strip end of error msg
    error_msg="ERROR ${error_msg##*: ERROR: }"  # Strip filename to error msg

    _print_item_fail
    printf >> "$log_file" '%s [%s] %s\n' "$item" "$operation" "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
    rm -f "$blocks"
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  fi

  # Skip if there were no PICTURE blocks found in current FLAC
  if [[ ! -s "$blocks" ]]; then
    _print_item_skip
    rm -f "$blocks"
    printf >&3 "$row\n"  # Send complete to _run_parallel()
    return
  fi

  _print_item_half  # Metaflac doesn't display a percentage complete

  # Store the values which can identify each image (in each PICTURE block) to
  # be used during image extraction.  The values needed are:
  #   'METADATA block #<num>'           -> $block_id
  #   '  type: <num> (<description>)'   -> $art_id AND $art_description
  #   '  MIME type: image/jpeg'         -> $mime
  #
  # NOTE:
  #   Reading the PICTURE block from a temporary file is much faster than
  #   reading from process substitution (there can be many PICTURE blocks in a
  #   single FLAC file and each image could be very large)
  while IFS=$'\n' read -r; do
    # Skip all the unnecessary information
    [[ "$REPLY" != 'METADATA'* && "$REPLY" != '  '[tM]* ]] && continue

    if [[ "$REPLY" == 'METADATA'* ]]; then
      block_id="${REPLY##*#}"
      continue
    fi

    # Ensure we don't use: 'type: 6 (PICTURE)'
    if [[ "$REPLY" == '  type: '[^6]* ]]; then
      IFS=' ' read -r _ art_id art_description <<< "${REPLY//\//-}"
      art_description="${art_description//[()]}"  # Strip all parenthesis
      art_description="${art_description// /_}"   # Spaces with underscores
      continue

    # Done with a PICTURE block; the values can be stored and variables reset
    elif [[ "$REPLY" == '  MIME'* ]]; then
      mime="${REPLY##*/}"     # Eg: 'MIME type: image/jpeg' -> 'jpeg'
      mime="${mime/jpeg/jpg}" # Eg: 'jpeg'                  -> 'jpg'

      # Eg: '4:3-Cover_front.jpg'
      artwork+=( "${block_id}:${art_id}-${art_description}.${mime}" )
      unset -v block_id art_id art_description mime
    fi
  done < "$blocks"
  rm -f "$blocks"

  # Continue only if there was artwork to be extracted
  if [[ -z "${artwork[@]}" ]]; then
    printf >&3 "$row\n"  # Send complete to _run_parallel()
    return
  fi

  # Determine where to put extracted artwork by checking user config
  if [[ -n "$artwork_location" ]]; then
    # /user/configured/path/to/artwork/file.flac.art.0
    artwork_location="${artwork_location%/}/${item##*/}.art.0"
  else
    # /path/to/file.flac.art.0
    artwork_location="${item}.art.0"
  fi

  # Ensure we don't clobber the artwork directory, eg:
  #   /path/to/file.flac.art.0 -> /path/to/file.flac.art.1
  #
  # Or if the user configured an artwork directory from the configuration file:
  #   /user/configured/path/to/artwork/file.flac.art.0 ->
  #   /user/configured/path/to/artwork/file.flac.art.1
  until [[ ! -d "$artwork_location" ]]; do
    artwork_location="${artwork_location%.*}.$((${artwork_location##*.} + 1))"
  done
  mkdir -p "$artwork_location"

  # Performs artwork extraction on the current item.  Each array value is:
  #   '<block_id>:<art_id>-<art_description>.<mime>
  #
  # Which looks like:
  #   '4:3-Cover_front.jpg'
  for value in "${artwork[@]}"; do
    # Eg: '/path/to/file.flac.art.0/3-Cover_front.jpg.0'
    img="${artwork_location}/${value#*:}.0"
    block_id="${value%%:*}"  # Eg: '4:3-Cover_front.jpg' -> '4'

    # Ensure we don't clobber the extracted image, eg:
    #   /path/to/file.flac.art.0/3-Cover_front.jpg.0 ->
    #   /path/to/file.flac.art.0/3-Cover_front.jpg.1
    until [[ ! -f "$img" ]]; do
      img="${img%.*}.$((${img##*.} + 1))"
    done

    # Extracts each image by METADATA block number
    metaflac --block-number="$block_id" --export-picture-to="$img" "$item"
  done

  _print_item_ok
  printf >&3 "$row\n"  # Send complete to _run_parallel()
}

#
# Prune user configurable FLAC metadata from FLAC files
#
_prune()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output error_msg

  _print_item 'Prune Metadata'
  _print_item_half  # Metaflac doesn't display a percentage complete

  # Remove all information but STREAMINFO,VORBIS_COMMENTs, and
  # possibly METADATA_BLOCK_PICTURE
  while IFS=$'\n' read -r output; do
    # Error reading FLAC file (possibly fake), eg:
    #   fake/fake.flac: ERROR: reading metadata, status = "FLAC ..."
    if [[ "$output" == *'ERROR'* ]]; then
      error_msg="${output%, status = *}"      # Strip status
      error_msg="ERROR${error_msg#*: ERROR}"  # Strip filename
      break                                   # Stop reading lines
    fi
  done < <(
    metaflac 2>&1 \
      $metaflac_extra_options --remove --dont-use-padding \
      --except-block-type="$dont_prune_flac_metadata" "$item"
  )

  # Log failures if there are any errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [%s] %s\n' "$item" "$operation" "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    _print_item_ok
  fi

  # Send complete to _run_parallel()
  printf >&3 "$row\n"
}

###################################  SETUP  ###################################

shopt -s globstar                      # BASH 4 globstar (eg, /**/*.flac)

version='0.31_pre'                     # Redoflacs version
flac_extension='.[Ff][Ll][Aa][Cc]'     # FLAC extension (case-insensitive)
unit_separator=$'\037'                 # ASCII unit separator

declare -i script_revision='4'         # Script user configuration revision
declare -A operation_summary           # Stores all the operational states

# Colors on by default
reset=$'\033[0m'
invert=$'\033[7m'
red=$'\033[31m'
green=$'\033[32m'
yellow=$'\033[33m'
blue=$'\033[34m'
magenta=$'\033[35m'
cyan=$'\033[36m'

#############################  PRE-SCRIPT CHECKS  #############################

# Check if user is running under Cygwin and if so, warn user and exit
if [[ "$(uname -o)" == 'Cygwin' ]]; then
  _error 'This version of redoflacs is meant to be run under\n'
  _error "${cyan}UNIX/Linux/BSD${reset}.  Please use the ${cyan}Windows (Cygwin)${reset}\n"
  _error 'version located here:\n'
  _error "${cyan}https://github.com/sirjaren/redoflacsw${reset}\n"
  exit 1
fi

#------------------------------------------------------------------------------

# Create/source either system or user config
if (( EUID == 0 )); then
  config_file='/etc/redoflacs.conf'               # System (root) config
else
  config_file="${HOME}/.config/redoflacs/config"  # User config
fi

# Check if system-wide configuration doesn't exist
if [[ ! -f "${config_file}" ]]; then
  mkdir -p "${config_file%/*}"  # Create directory if it doesn't exist
  _create_config                # Create configuration file

  _info 'A configuration file has been created here:\n'
  _info "${cyan}${config_file}${reset}\n\n"

  _info 'Please review it before running this program.\n'

  exit 0
else
  _parse_config                 # Parse and source configuration file
fi

#------------------------------------------------------------------------------

# Generate log file location
#--
# Ensure we don't overwrite an existing log file by incrementing the current PID
# by 1 until the log file that is to be set, doesn't exist
pid="$$"
log_file="${error_log}/redoflacs_${pid}.log"

until [[ ! -f "${log_file}" ]]; do
  log_file="${error_log}/redoflacs_log_$((pid++)).log"
done

#------------------------------------------------------------------------------

_process_positional_parameters "${@}"  # Process CLI arguments

#------------------------------------------------------------------------------

# Disable color if user called '-n, --no-color'
[[ "${no_color}" == 'true' ]] && unset -v blue green red cyan magenta yellow

#------------------------------------------------------------------------------

# Make sure we are running BASH 4 or greater
if (( ${BASH_VERSINFO[0]} < 4 )); then
  _error "You must be running ${cyan}BASH 4${reset} or greater to use\n"
  _error '"this program!\n'
  exit 1
fi

#------------------------------------------------------------------------------

# Check for any conflicting operations/arguments called and warn user
_check_conflicting_operations

#------------------------------------------------------------------------------

# For each operation that was selected, add to $operation_summary[@]
for operation in "${operations[@]}"; do
  _update_operation_status "${operation}" 'Operation Did Not Run'
done
#------------------------------------------------------------------------------

_check_missing_programs  # Check for missing programs vital to this script

#------------------------------------------------------------------------------

# Check whether directory exists
if [[ ! -d "${directory}" ]]; then
  printf ' Usage: redoflacs [OPTION] [PATH_TO_FLAC(s)]...\n' >&2
  _error 'Please specify a directory!\n'
  exit 1
fi

#------------------------------------------------------------------------------

# Check for at least 1 FLAC file
read -r find_flacs < <( printf "%s\n" "${directory}"/**/*${flac_extension} )

if [[ ! -f "${find_flacs}" ]]; then
  _error 'There are not any FLAC files to process!\n'
  exit 1
fi

#------------------------------------------------------------------------------

# If '-e, --extract-artwork' was called, make sure $artwork_location is valid
if [[ "${operations[9]}" == 'extract_images' ]]; then
  # Check if artwork_location is user-defined
  if [[ -n "${artwork_location}" ]]; then
    # Put extracted artwork in user-defined location, testing to make sure
    # the directory exists
    if [[ ! -d "${artwork_location}" ]]; then
      _error "${cyan}${artwork_location%/}${reset} doesn't exist!\n"
      _error 'Please set a valid directory in the configuration file!\n'
      exit 1
    fi
  fi
fi

# If '-A, --aucdtect-spectrogram' was called, make sure $spectrogram_location is
# valid
if [[ "${create_spectrogram}" == 'true' ]]; then
  # Check if spectrogram_location is user-defined
  if [[ -n "${spectrogram_location}" ]]; then
    # Put spectrograms in user-defined location, testing to make sure the
    # directory exists
    if [[ ! -d "${spectrogram_location}" ]]; then
      _error "${cyan}${spectrogram_location}${reset} doesn't exist!\n"
      _error 'Please set a valid directory in the configuration file!\n'
      exit 1
    fi
  fi
fi

#------------------------------------------------------------------------------

#
# Dynamically sets the number of jobs to use if the user did not specify
# them via a positional paramter, defaulting to two (2) jobs if unable
# find the number of online CPU's to determine the number of jobs
#
jobs="${jobs:-"$(command -p nproc 2>/dev/null)"}"
jobs="${jobs:-"$(command -p getconf _NPROCESSORS_ONLN 2>/dev/null)"}"
jobs="${jobs:-"$(command -p sysctl -n hw.ncpu 2>/dev/null)"}"
jobs="${jobs:-2}"

###################################  MAIN  ####################################

printf '\033[?25l'                 # Hide cursor
printf '\033[?7l'                  # Disable terminal wrapping

export LANG=C
export LC_ALL=C

_check_config_version              # Check if script config is newer than user's
job_fifo="/tmp/redoflacs_fifo_$$"  # Job manager FIFO

issue_ticks="/tmp/redoflacs_issue_file_$$"           # Issues/Errors file

# _retag(): Display a countdown
[[ -n "${operations[7]}" ]] && _countdown_metadata

_info 'Finding FLAC files to process...'

# Total FLACs to process
pushd "$directory" >/dev/null
total_items=( "${PWD}"/**/*${flac_extension} )  # Absolute pathname
popd >/dev/null

# This displays '[ ok ]' after 'Finding FLAC files to process...'
printf "%11s${blue}[ ${green}ok${blue} ]${reset}\n" ''

#------------------------------------------------------------------------------

#
# Obtain the total number of lines and columns available in the terminal by
# sending the following control sequences to the controlling terminal:
#   CSI s              # Save cursor position
#   CSI 999999 C       # Move cursor all the way to end of the current row
#   CSI 6 n            # Query cursor position
#   CSI 999999 D       # Move cursor back to the beginning of the current row
#   CSI u              # Restore cursor position
#
# 'CSI 6 n' reports/returns the cursor position/terminal size as:
#   CSI height ; width R
#
# An example:
#   '\033[80;23R'
#
# Send CSI escape to (and read from) STDERR to not pollute STDIN
IFS='[;' \
  read -rsu2 -d'R' -p $'\033[s\033[999999;999999H\033[6n\033[u' _ lines columns

# The maximum length is one higher than the display width as output is
# displayed using escape sequences, making shell arithmetic inclusive off by
# one
if ((columns < 80)); then
  readonly MAX_LENGTH="$((++columns))"
else
  readonly MAX_LENGTH='81'
fi

#------------------------------------------------------------------------------

for operation in "${operations[@]}"; do
  # Loop through the various operations to run.  All the operations are to be
  # run, in order, which is detailed below:
  #   operations[0]='aucdtect'
  #   operations[1]='md5check'
  #   operations[2]='compress_verify'
  #   operations[3]='compress_no_test'
  #   operations[4]='test'
  #   operations[5]='replaygain_test'
  #   operations[6]='replaygain_force_apply'   # Conditionally set
  #   operations[6]='replaygain_apply'         # Conditionally set
  #   operations[7]='retag'
  #   operations[9]='extract_images'
  #   operations[10]='prune'
  #--
  case "${operation}" in
    'replaygain')
      total_items_backup=( "${total_items[@]}" )  # Total FLACs backup array
      for dir in "${total_items[@]%/*}"; do
        previous="$current"
        current="$dir"
        [[ "$previous" != "$current" ]] && total_dirs+=( "$current" )
      done
      total_items=( "${total_dirs[@]}" )          # Now process directories
    ;;
    'prune')
      # Set which FLAC metadata BLOCKS to remove
      if [[ "${remove_artwork}" == 'true' ]]; then
        # Remove PICTURE block
        dont_prune_flac_metadata='STREAMINFO,VORBIS_COMMENT'
      else
        # Do not remove PICTURE block
        dont_prune_flac_metadata='STREAMINFO,PICTURE,VORBIS_COMMENT'
      fi
    ;;
  esac

  _message "${operation}"        # Display title message of current operation
  _scroll_terminal               # Scroll terminal up (if needed)
  _clear_jobs_fd "${job_fifo}"   # Clear job manager file descriptor (3)

  if (( ${#total_items[@]} < jobs )); then
    # Set row position to place cursor after completing an operation or trap
    #--
    # If the items to process are less than the number of jobs, add the number
    # of items to the current row position, else add the number of jobs to run
    items_processed="${#total_items[@]}"
  else
    items_processed="${jobs}"
  fi

  post_row=$(( $(_row) + items_processed ))  # After operation row position

  trap '_trap_sigint "${operation}"' SIGINT  # Clean exit on SIGINT
  _run_parallel "${operation}"   # Run a given operation with parallel jobs

  for (( i=1; i<=items_processed; i++)); do
    # Clear all the operation lines by moving up each line and clearing it,
    # until we are just below the operation's title message
    #--
    printf "\033[$(( post_row - i))H%${columns}s" ''
  done

  # Display number of finished items minus items with issues
  _message "${operation}" "$(( iteration - $(_num_issues) ))"  # Update title message

  # Update status for the current operation
  _update_operation_status "${operation}" 'Operation Completed'

  if [[ -f "${log_file}" ]]; then
    _message_log_exists "${operation}"  # Print out log exists to STDERR
    _summary                            # Display Summary Of Operations
    exit 1
  fi

  # Restore the items to process from directories to FLACs
  [[ "${operation}" == 'replaygain_'*'apply' ]] && total_items=( "${total_items_backup[@]}" )
done

#------------------------------------------------------------------------------

_summary  # Display Summary Of Operations
