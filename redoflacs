#!/usr/bin/env bash
# vim: ts=2:sts=2:sw=2:et:ft=sh:
#
# NAME
#   redoflacs - BASH commandline FLAC compressor, verifier, organizer,
#               analyzer, and retagger
#
# FILE INFORMATION
#   Author:        Jaren Stangret <sirjaren@gmail.com>
#   Homepage:      https://github.com/sirjaren/redoflacs
#   Dependencies:  BASH >= 4.0
#
# DISTRIBUTION
#   Copyright 2020 Jaren Stangret
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
#   implied. See the License for the specific language governing
#   permissions and limitations under the License.
#

#############################  FUNCTIONS  ##############################

#
# Convenience functions to provide messages to the user with colored
# prefixes to indicate message severity, eg:
#   _warn 'This is obsolete'
#
# Creates a messsage like:
#    * This is obsolete
#
# With the asterisk colored yellow
#
_info() { printf     " $green*$reset $@\n";  }  # Green
_warn() { printf >&2 " $yellow*$reset $@\n"; }  # Yellow
_error(){ printf >&2 " $red*$reset $@\n";    }  # Red

#
# Display help
#
_help()
{
  local REPLY

  IFS='' read -rd '' << HELP_EOF
Usage: redoflacs [operations] [options] [target] ...

Operations:
  -c       Compress FLAC files
  -C       Compress FLAC files (even if COMPRESSION tag already exists)
  -t       Test integrity of FLAC files
  -m       Check for a valid MD5 signature in FLAC files STREAMINFO block
  -a       Use auCDtect to authenticate FLAC files
  -A       Use auCDtect to authenticate FLAC files (create spectrogram)
  -e       Extract all embedded artwork from FLAC files
  -p       Remove metadata blocks from FLAC files (PADDING, PICTURE, etc)
  -g       Apply ReplayGain to FLAC files
  -G       Apply ReplayGain to FLAC files (even if ReplayGain tags exist)
  -r       Retag FLAC files preserving user-defined tags

Options:
  -j[N]    Allow N jobs at once, dynamically determined if unspecified
  -n       Disable color output
  -x       Do not apply COMPRESSION tag when compressing FLAC files
  -o       Generate a new configuration file and exit
  -v       Print the version number of redoflacs and exit
  -h       Print this message and exit

See redoflacs(1) for more information.
HELP_EOF

  printf '%s' "$REPLY"
}

#
# Display usage
#
_usage()
{
  printf >&2 ' Usage: redoflacs [operations] [options] [target] ...\n'
}

#
# Print out the correct operational message regarding a log file's
# existence and what infomration that log may contain.
#
# $1 determines the log file to use, as well as how many lines are
# printed out to correctly set the current row.  Possible values:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#
_message_log_exists()
{
  case "$1" in
    'aucdtect')
      _error 'Some FLAC files may be lossy sourced, please check:\n'
    ;;
    'md5check')
      _error 'The MD5 Signature is unset for some FLAC files or there were\n'
      _error 'issues with some of the FLAC files, please check:\n'
    ;;
    'compress'*|'test'|'replaygain_test'|'extract_images'|'prune')
      _error 'There were issues with some of the FLAC files,\n'
      _error 'please check:\n'
    ;;
    'replaygain')
      _error 'There were issues adding ReplayGain values,\n'
      _error 'please check:\n'
    ;;
    'retag')
      _error 'Some FLAC files have missing tags or there were\n'
      _error 'issues with some of the FLAC files, please check:\n'
    ;;
  esac

  # Print the bottom half of the message (uniform across all operations)
  _error "${cyan}${log_file}${reset}\n"
  _error 'for details.\n'
}

#
# Print out current operation message
#
# $1 determines which title message to print (if any).  Possible values:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#
# $2 is the number of processed items (iteration)
#
# $3 is conditionally called, and appears if the operation was
# interrupted:
#   Interrupted operation: $3 == 'interrupt'
#     Operation completed: $3 is NULL
#
_message()
{
  # Set up local variables
  declare message sub_message
  declare -i issues spacing

  # Print title message if $1 is not NULL
  if [[ -n "${1}" ]]; then
    case "${1}" in
      'aucdtect')       message='Validating with auCDtect'                ;;
      'md5check')       message='Check MD5 Signature'                     ;;
      'compress')       message="Level ${compression_level} Compression"  ;;
      'test')           message='Test FLACs'                              ;;
      'extract_images') message='Extracting Artwork'                      ;;
      'replaygain')     message='Applying ReplayGain'                     ;;
      'retag')          message='Retagging FLACs'                         ;;
      'prune')          message='Prune METADATA Blocks'                   ;;
    esac

    # Print title message, if applicable
    if [[ -n "${message}" && -z "$2" ]]; then
      printf "\033[$(_row)H ${green}*${reset} ${message}\n"
    fi

    # Print sub title message, if applicable
    if [[ -n "${sub_message}" && -z "$2" ]]; then
      printf "\033[$(_row);3H${green}>>${reset} ${sub_message}\n"
    fi
  fi

  # Update title/sub title message only if $2 is not NULL
  if [[ -n "${2}" ]]; then
    issues=$(_num_issues)  # Number of issues

    # Specify color according to operation status
    [[ "${3}" == 'interrupt' ]] && color="${cyan}" || color="${green}"

    # Verbage for singular/plural issues
    (( issues == 1 )) && issue_string='issue ' || issue_string='issues'

    if [[ -n "${sub_message}" ]]; then
      # Space between message and number of items proccessed
      spacing=$((44 - ${#sub_message} - ${#2} - ${#issues} - 14))

      # Sub title message
      printf "\033[2A   ${green}>>${reset} %s%${spacing}s${blue}[ ${color}%d ok${blue} | ${red}%d ${issue_string}${blue} ]${reset}\n" \
        "${sub_message}" '' "$2" "${issues}"
    else
      # Space between message and number of items proccessed
      spacing=$((46 - ${#message} - ${#2} - ${#issues} - 14))

      # Title message
      printf "\033[2A  ${green}*${reset} %s%${spacing}s${blue}[ ${color}%d ok${blue} | ${red}%d ${issue_string}${blue} ]${reset}\n" \
        "${message}" '' "$2" "${issues}"
    fi
  fi
}

#
# Displays the currently processed item on a dedicated row within the
# terminal
#
# The filename is truncated if the length of the filename is greater
# than 80 characters or if greater than the width of the terminal if
# that terminal width is less than 80. This width is set by 'MAX_LENGTH'
#
# Filename truncation also occurs to allow the operation label (via $1)
# and the total number of completed items to be displayed on the same
# row as the displayed item
#
# The structure of a displayed item:
#   '<percent> <basename>          <operation_label> <number_completed>'
#
# Which may look like:
#   '     06 - Some Amazing Song.flac                     Testing  6/20'
#
# This function does NOT create the display the percentage completed.
# That is handled later
#
# The file basename is left-aligned (leaving room for the percentage),
# while the operation label and total number of completed items are
# right-aligned
#
# An example of filename truncation:
#   '01 - This is a long name showing truncation.flac'
#
# This filename would be displayed during an operation as:
#   '     01 - This is a long name showing truncation.fla Testing  6/20'
#
# An example of how this would look with a percentage displayed:
#   ' 56% 06 - Some Amazing Song.flac                     Testing  6/20'
#
_print_item()
{
  local fmt truncated
  local basename="${item##*/}"
  local label="${1:+ ${1}}"  # Operation label (with leading space)

  # The total number of items out of the total number of items, used to
  # determine the maximum width these values can use, eg:
  #   ' 237/237'
  #
  # The leading space is intentional, to ensure a space is between the
  # item basename and this value
  local total=" ${#total_items[@]}/${#total_items[@]}"

  # This is the column position after the item basename is displayed.
  # This allows the operation label and total number of completed items
  # to be displayed after this column, effectively truncating the
  # current item if longer than this column position
  truncated="$(( MAX_LENGTH - ${#total} - ${#label} ))"

  # Belows builds the 'printf' format string
  fmt+=$"\033[${row};6H"              # Cursor row; 6 columns to right
  fmt+=$"\033[0K"                     # Erase line from cursor to right
  fmt+='%s'                           # Modifier; Current item basename
  fmt+=$"\033[${row};${truncated}H"   # Cursor row; Move to allow items
  fmt+=$"\033[0K"                     # Erase line from cursor to right
  fmt+="${magenta}%s"                 # Modifier; Operation label
  fmt+="${cyan}%${#total}s${reset}"   # Modifier; Items, right-aligned

  # Displays formatted, currently processed item
  printf "$fmt" "$basename" "$label" "${num}/${#total_items[@]}"
}

#
# These functions are used after '_print_item()' to update/indicate the
# status of a given item in an operation
#
_print_item_ok()   { printf "\033[${row}H${green}100%%$reset"; }
_print_item_fail() { printf "\033[${row}H${red}fail$reset";    }
_print_item_check(){ printf "\033[${row}H${yellow}chck$reset"; }
_print_item_half() { printf "\033[${row}H$yellow 50%%$reset";  }
_print_item_skip() { printf "\033[${row}H${cyan}skip$reset";   }

#
# Kill any children process and display the correct interrupt message
# when a user sends SIGINT during script execution. Perform any cleanup,
# and check for the existence of a log file before exiting script.
#
# $1 determines which additional cleanup may need to be performed based
# off of operation interrupted, as well as whether the trap is invoked
# during a countdown interruption. Possible values:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#   countdown
#
_trap_sigint()
{
  # Set up local variables
  declare    finished_items
  declare -a jobs_running=( $(jobs -rp) )  # Store children processes

  _kill_jobs ${jobs_running[@]}            # Kill children processes

  for (( i=1; i<=items_processed; i++)); do
    # Clear all the operation lines by moving up each line and clearing
    # it, until we are just below the operation's title message
    printf "\033[$(( post_row - i))H%${columns}s" ''
  done

  # Update title message, don't update if SIGINT was during a countdown
  if [[ "$1" != 'countdown' ]]; then
    # The number of completely finished (ok) items, minus any items
    # interrupted, minus items with issues
    finished_items="$(( iteration - ${#jobs_running[@]} - $(_num_issues) ))"
    _message "${operation}" "${finished_items}" 'interrupt'
  fi

  # Display extra newline if user invoked SIGINT during a countdown
  [[ "$1" == 'countdown' ]] && printf '\n'

  printf " ${green}*${reset} SIGINT received, generating summary...\n"

  case "${1}" in
    # Remove temporary script-created files
    #--
    'aucdtect'*) rm -f "${directory}"/**/*_redoflacs_"$$".wav  ;;
    'compress')  rm -f "${directory}"/**/*.tmp,fl-ac+en\'c     ;;
  esac

  # Update operation status to interrupted
  operations["$operation"]='Interrupted'

  # Print out log exists to STDERR
  [[ -f "${log_file}" ]] && _message_log_exists "${1}"

  printf '\033[?25h'            # Restore the cursor
  printf '\033[?7h'             # Restore terminal wrapping
  rm -f "$job_fifo"             # Remove temporary FIFO
  rm -f "$tmp_picture_blocks"   # Remove temporary 'metaflac' blocks
  _summary                      # Display Summary Of Operations

  exit 130
}

#
# Display redoflacs version
#
_print_version() { printf 'Version %s\n' "${version}"; }

#
# Return metaflac version
#
_metaflac_version()
{
  # Metaflacs version (ie: '2' in 1.2.1)
  IFS='.' read -r _ metaflac_version _ < <(metaflac --version)
  printf '%s' "${metaflac_version}"
}

#
# Kill any children process (obtained via $@), hiding errors and
# suppressing the shell's notification of terminated jobs
#
_kill_jobs()
{
  for pid in $@ ; do
    kill ${pid} 2>/dev/null
    wait ${pid} 2>/dev/null
  done
}

#
# Return the current cursor's row position by sending the following
# control sequence to the controlling terminal:
#   CSI 6 n            # Query cursor position
#
# Which reports/returns the cursor position/terminal size as:
#   CSI height ; width R  # eg. '\033[80;23R'
#
_row()
{
  local row

  # Send CSI escape to (and read from) STDERR to not pollute STDIN
  IFS='[;' read -rsu2 -d'R' -p $'\033[6n' _ row _

  printf '%s' "$row"
}

#
# If necessary, scroll the terminal
#
_scroll_terminal()
{
  local row to_scroll

  # Obtain current row position
  row="$(_row)"

  # Default to scrolling the terminal based on the number of jobs
  to_scroll="$jobs"

  # Scrolling by number of items to process
  (( jobs > ${#total_items[@]} )) && to_scroll="${#total_items[@]}"

  # Only scroll if there are more items to display than lines available
  if (( --to_scroll > (lines - row) )); then
    printf "\033[$((to_scroll - (lines - row)))S"  # Scroll terminal
    printf "\033[$((lines - to_scroll))H"          # Cursor to start
  fi
}

#
# Force the creation of a new configuration file
#
_new_config()
{
  # Check if configuration file exists based of ${EUID}.  If it doesn't
  # exist, create one
  if (( EUID == 0 )); then
    # User is root
    #--
    # Configuration file location
    config_file='/etc/redoflacs.conf'

    # If there already is a configuration file, do not overwrite it
    if [[ -f "${config_file}" ]]; then
      config_file="/etc/_$$.redoflacs.conf"
    fi
  else
    # User is _NOT_ root
    #--
    # Configuration file location
    config_file="${HOME}/.config/redoflacs/config"

    # If there already is a configuration file, do not overwrite it
    if [[ -f "${config_file}" ]]; then
      config_file="${HOME}/.config/redoflacs/_$$.config"
    fi
  fi

  # Creates the (new) configuration file
  _create_config

  # Explain to user where to find the new configuration file
  _info 'A new configuration file has been created here:\n'
  _info "${cyan}${config_file}${reset}\n\n"

  _info "It's recommended to review the new configuration file\n"
  _info 'and transfer over any changes you made in your old\n'
  _info 'configuration file.\n\n'

  _info 'After making the changes (if any), rename the new\n'
  _info 'configuration file to your old configuration file\n'
  _info 'name.  Here is the command you could use:\n'

  if (( EUID == 0 )); then
    _info "${cyan}mv${reset} ${cyan}${config_file}${reset} ${cyan}/etc/redoflacs.conf${reset}\n"
  else
    _info "${cyan}mv${reset} ${cyan}${config_file}${reset} ${cyan}${HOME}/.config/redoflacs/config${reset}\n"
  fi
}

#
# Create a configuration file
#
_create_config()
{
  # Set up local array
  declare -a config

  # Don't expand variables when using heredoc
  mapfile -n0 -t config << "END_OF_CONFIG"
#
# redoflacs configuration
#
# Any line that is _NOT_ prepended with a '#' will be interpreted as an option
# (except for blank lines -- these are not interpreted)
#
# See redoflacs(1) for a detailed description of each parameter
#
# NOTE: The options listed below are shell syntax.  Interpolation can occur
# should weak (double) quotes be used.
#
#------------------------------------------------------------------------------
# TAGGING SECTION
#------------------------------------------------------------------------------
#
# List the tags to be kept in each FLAC file.  The default is listed below.
#
# Another common tag not added by default is ALBUMARTIST.  Uncomment
# ALBUMARTIST below to allow script to keep this tag.
#
# NOTE: Whitespace _IS_ allowed for the these tag fields, ie:
#   ALBUM ARTIST
#   CATALOG NUMBER ISBN
#
TITLE
ARTIST
#ALBUMARTIST
ALBUM
DISCNUMBER
DATE
TRACKNUMBER
TRACKTOTAL
GENRE

# The COMPRESSION tag is a custom tag to allow the script to determine which
# level of compression the FLAC file(s) has/have been compressed at.
COMPRESSION

# The RELEASETYPE tag is a custom tag the author of this script uses to
# catalog what kind of release the album is (ie, Full Length, EP, Demo, etc.).
RELEASETYPE

# The SOURCE tag is a custom tag the author of this script uses to catalog
# which source the album has derived from (ie, CD, Vinyl, Digital, etc.).
SOURCE

# The MASTERING tag is a custom tag the author of this script uses to catalog
# how the album has been mastered (ie, Lossless, or Lossy).
MASTERING

# The REPLAYGAIN tags below, are added by the '-g, --replaygain' or
# '-G, --replaygain-noforce' argument.  If you want to keep the ReplayGain
# tags, make sure you leave these here.
REPLAYGAIN_REFERENCE_LOUDNESS
REPLAYGAIN_TRACK_GAIN
REPLAYGAIN_TRACK_PEAK
REPLAYGAIN_ALBUM_GAIN
REPLAYGAIN_ALBUM_PEAK

#------------------------------------------------------------------------------
# OPTIONS
#------------------------------------------------------------------------------
#
# REMOVE ARTWORK:
#
# Set whether to remove embedded artwork within FLAC files.  By default, this
# script will remove any artwork it can find in the PICTURE block of a FLAC
# file.  Set 'remove_artwork' as 'true' to remove embedded artwork.  All other
# values are intepreted as 'false'.
remove_artwork='true'

#
# SET COMPRESSION:
#
# Set the type of COMPRESSION strength when compressing the FLAC files.
# Numbers range from '1-8', with '1' being the lowest compression and '8' being
# the highest compression.  The default is '8'.
compression_level='8'

#
# ERROR LOG DIRECTORY:
#
# Set where you want error logs to be placed.  By default, they are stored in
# the user's HOME directory.
error_log="${HOME}"

#
# AUCDTECT SKIP LOSSY:
#
# Set whether FLAC files should be skipped if the MASTERING tag is already set
# as 'Lossy' when analyzed with auCDtect.  Set 'skip_lossy' as 'true' to to
# skip FLAC files that have the tag: 'MASTERING=Lossy'.  All other values are
# intepreted as 'false'.
skip_lossy='true'

#
# SPECTROGRAM DIRECTORY:
#
# Set where created spectrogram images should be stored.  By default, they are
# stored in the same directory as the analyzed FLAC files.  Each image will
# have the same name as the tested FLAC file but with an integer suffix
# indicating the FLAC number (which was processed by the script) to allow for
# uniqueness.  The type of image created is PNG with the extension '.png'.
#
# All values for 'spectrogram_location' are interpreted as a directory.  If
# left blank, the default location will be used.
#
# An example of a user-defined location:
#    spectrogram_location="${HOME}/Spectrogram_Images"
#
# See redoflacs(1) for more information.
spectrogram_location=''

#
# EXTRACTED ARTWORK DIRECTORY:
#
# Set where the extracted artwork images should be stored.
#
# By  default, each extracted image will be placed in a subdirectory where the
# FLAC file is located.  The subdirectory housing the extracted artwork will
# have a similar name as the currently processed FLAC.  If a directory already
# exists, an integer is appended to the directory (to prevent overwriting and
# mixing files).  For example:
#
#    /path/to/01_file.flac          # FLAC file with embedded artwork
#    /path/to/01_file.flac_art/     # Directory housing artwork
#    /path/to/01_file.flac_art~1~/  # Directory '1' if above directory exists
#    /path/to/01_file.flac_art~2~/  # Directory '2' if above directory exists
#    /path/to/01_file.flac_art~N~/  # Directory 'N' if above directory exists
#
# All values for 'artwork_location' are interpreted as a directory.  If left
# blank, the default location will be used.
#
# If there is a user-defined location, the extracted images will be placed in a
# subdirectory in that location with a naming scheme similar to above:
#
#    artwork_location="${HOME}/artwork"    # User-defined configuration option
#
#    /path/to/01_file.flac                 # FLAC file with embedded artwork
#    ${HOME}/artwork/01_file.flac_art/     # Directory housing artwork
#    ${HOME}/artwork/01_file.flac_art~1~/  # If above directory exists
#
# See redoflacs(1) for more information.
artwork_location=''

#
# PREPEND TRACK NUMBER:
#
# Change whether the '-r, --retag' operation will re-tag singular track numbers
# and track totals from:
#    1, 2, 3, 4, 5, 6, 7, 8, 9
# to
#    01, 02, 03, 04, 05, 06, 07, 08, 09
#
# For example, if you had:
#    TRACKNUMBER=4
#     TRACKTOTAL=9
#
# You would end up with:
#    TRACKNUMBER=04
#     TRACKTOTAL=09
#
# This is enabled by setting 'prepend_zero' option as 'true'.  All other values
# are interpreted as 'false'.
prepend_zero='false'

#
# PRESERVE FILE MODIFICATION TIME:
#
# This is enabled by setting 'preserve_modtime' option as 'true'.  All other
# values are interpreted as 'false'
preserve_modtime='false'

# Version:4
END_OF_CONFIG

  # Write out configuration to either system-wide or local location
  printf '%s\n' "${config[@]}" > "${config_file}"
}

#
# Parse the user/system configuration file
#
_parse_config()
{
  local line
  local -ga tags_to_keep  # Global array used in _retag() function

  # Used to skip irrelevant configuration file lines
  local regex='^([[:space:]]+|#.*|)$'

  # Process the configuration file, storing all user-defined tags and
  # evaluate each configuration option
  while IFS=$'\n' read -r line; do
    # Skip empty lines, comment lines and lines with whitespace
    [[ "$line" =~ ^([[:space:]]+|#.*|)$  ]] && continue

    # Evaluate configuration file option
    if [[ "$line" == *'='* ]]; then
      eval "$line"
      continue
    fi

    # These are user-defined FLAC tags stored into a global array
    tags_to_keep+=( "${line^^}" )
  done < "$config_file"

  if [[ "$preserve_modtime" == 'true' ]]; then
    metaflac_extra_options='--preserve-modtime'
  fi
}

#
# Check current configuration, if the version in the script is newer
# warn user and display a countdown before starting script
#
_check_config_version()
{
  # Set up local variables/arrays
  declare    config_file  config_last_line  revision
  declare -a config_array

  # Check if configuration file exists based of ${EUID}.  If it doesn't
  # exist, create one
  if (( EUID == 0 )); then
    # User is root
    #--
    # Configuration file location
    config_file='/etc/redoflacs.conf'
  else
    # User is _NOT_ root
    #--
    # Configuration file location
    config_file="${HOME}/.config/redoflacs/config"
  fi

  # Load configuration file into an array
  mapfile -n0 -t config_array < "${config_file}"

  # Obtain only the last line of the config
  config_last_line="${config_array[@]: -1}"

  # Extract the revision number from the configuration file (new syntax
  # format as of redoflacs 0.30):
  IFS=':' read -r _ revision <<< "$config_last_line"

  # Check if ${revision} is an integer.  If not, display countdown and
  # warn user of new configuration file, else test if the user config
  # revision is less than the script config revision
  if [[ "${revision}" =~ ^[[:digit:]]+$ ]]; then
    if (( script_revision > revision )); then
      _countdown_config; printf '\n\n'
    fi
  else
    _countdown_config; printf '\n\n'
  fi
}

#
# Display countdown before retagging to allow user to quit script safely
#
_countdown_metadata()
{
  trap '_trap_sigint countdown' SIGINT  # Trap SIGINT to abort cleanly

  # Warning message
  _error "${yellow}CAUTION!${reset} These are the tag fields that will be kept\n"
  _error 'when re-tagging the selected files:\n'

  # Creates the listing of tags to be kept
  printf '     %s\n' "${tags_to_keep[@]}" >&2

  # Warning message about embedded coverart
  _error "By default, this script will ${cyan}REMOVE${reset} the legacy ${cyan}COVERART${reset} tag.\n"
  _error "Add the ${cyan}COVERART${reset} tag to the list of tags to be kept in the\n"
  _error "${cyan}TAGGING SECTION${reset} of the configuration file.\n\n"

  _error "Keep in mind, if the ${cyan}remove_artwork${reset} option is set to ${cyan}false${reset},\n"
  _error "embedded artwork in the ${cyan}PICTURE${reset} block will be kept when using\n"
  _error "the ${cyan}-p, --prune${reset} option as well.\n\n"

  _warn "Waiting ${red}10${reset} seconds before starting program...\n"
  _warn 'Ctrl+C (Control-C) to abort...\n'
  _info 'Starting in: '

  # 10 second countdown
  for count in {10..1}; do
    printf "${red}%d ${reset}" "$count"
    read -t1  # Sleep 1
  done

  printf '\n'  # Advance countdown to next line
}

#
# Displays countdown if a newer config is found to allow user to quit
# safely
#
_countdown_config()
{
  trap '_trap_sigint countdown' SIGINT  # Trap SIGINT to abort cleanly

  # Warning message
  _info 'There is a newer configuration file available!\n\n'

  _warn 'It is recommended you generate a new configuration\n'
  _warn 'file for use with this program.\n\n'

  _warn 'To generate a new configuration file, run:\n'
  _warn "${cyan}redoflacs --new-config${reset}\n\n"

  _warn 'The above command will _NOT_ overwrite your\n'
  _warn 'current configuration file.\n\n'

  _warn 'Waiting 10 seconds before starting program...\n'
  _warn 'Ctrl+C (Control-C) to abort...\n'
  _info 'Starting in: '

  # 10 second countdown
  for count in {10..1}; do
    printf "${red}%s ${reset}" "$count"
    read -t1  # Sleep 1
  done
}

#
# Return an integer detailing the number of issues an operation may have
# had, returning '0', if no issues were found
#
_num_issues()
{
  declare ticks  # Set up local variable

  # Read in number of issue ticks, hiding missing file output
  { read -r ticks < "${issue_ticks}"; } 2>/dev/null
  printf '%d' "${#ticks}"  # Return number of ticks (0, if empty)
}

#
# Obtain and process the positional parameters invoked with the script
#
# The following global variables are defined, should options which
# define them are specified:
#
#   $create_spectrogram
#   $directory
#   $force_compression
#   $force_replaygain
#   $no_extra_tags
#   $operations_to_run[@]
#   $operations[@]
#
_process_arguments()
{
  # Global variables used in other functions/operations
  local -g create_spectrogram force_compression force_replaygain \
    operations_to_run no_extra_tags directory

  local arg invalid op
  local -a conflicting ordered_operations

  # Associative array containing operations to run and status of
  # operation
  local -Ag operations

  # Defined order to run all specified operations
  local -a ordered_operations=(
    '_md5check'
    '_test'
    '_compress'
    '_aucdtect'
    '_replaygain'
    '_retag'
    '_extract_images'
    '_prune'
  )

  # If no arguments are made to the script show usage and help
  if (( $# == 0 )); then
    _help
    exit 1
  fi

  # Processes all the possible positional parameters, short options
  # only, handling conflicting parameters
  while getopts ':j:cCtmaAepgGrnhvox' arg "$@"; do
    case "$arg" in
      # Given argument is not valid. 'OPTARG' is 'arg' before 'arg' is
      # set to '?'
      '?')
        [[ "$invalid" == *"-$OPTARG"* ]] && continue
        invalid+="${invalid:+ }-$OPTARG"
        ;;

      # Required parameter for a given argument was not specified
      ':')
        _error 'Option -j, requires a non-zero integer, eg: -j4'
        _help
        exit 1
        ;;

      # Help message and exit
      'h') _help; exit 0 ;;

      # Dipslay script version and exit
      'v') printf 'redoflacs %s\n' "$script_version"; exit 0 ;;

      # Create a new configuration file and exit
      'o') _new_config; exit 0 ;;

      # Disable color output
      'n') unset -v reset red green yellow blue magenta cyan ;;

      # Prevent COMPRESSION tag from being applied during compression
      'x') no_extra_tags='true' ;;

      # Test FLAC files
      't')
        if [[ -z "${operations['_test']}" ]]; then
          operations['_test']='Did Not Run'
        fi
        ;;

      # Validate MD5 checksum in FLAC files
      'm')
        if [[ -z "${operations['_md5check']}" ]]; then
          operations['_md5check']='Did Not Run'
        fi
        ;;

      # Extract embedded artwork from FLAC files
      'e')
        if [[ -z "${operations['_extract_images']}" ]]; then
          operations['_extract_images']='Did Not Run'
        fi
        ;;

      # Prune unnecessary metadata blocks from FLAC files
      'p')
        if [[ -z "${operations['_prune']}" ]]; then
          operations['_prune']='Did Not Run'
        fi
        ;;

      # Retag FLAC files
      'r')
        if [[ -z "${operations['_retag']}" ]]; then
          operations['_retag']='Did Not Run'
        fi
        ;;

      # Specify number of jobs to process FLAC files
      'j')
        # OPTARG is the (required) number after 'j'
        if [[ "$OPTARG" =~ ^[[:digit:]]+$ ]] && (( OPTARG != 0 )); then
          jobs="$OPTARG"
        else
          _error 'Option -j, requires a non-zero integer, eg: -j4'
          _help
        fi
        ;;

      # Compression and force compression arguments
      'c'|'C')
        # Skip as both compression arguments were already specified
        [[ "${conflicting[@]}" == *'-c, -C'* ]] && continue

        # Add compression to operation as it does not yet exist
        if [[ -z "${operations['_compress']}" ]]; then
          [[ "$arg" == 'C' ]] && force_compression='true'
          operations['_compress']='Did Not Run'
          continue
        fi

        # '-C' was already specified and '-c' is the current argument
        if [[ "$arg" == 'c' && "$force_compression" ]]; then
          conflicting+=( '-c, -C' )

        # '-c' was already specified and '-C' is the current argument
        elif [[ "$arg" == 'C' && ! "$force_compression" ]]; then
          conflicting+=( '-c, -C' )
        fi
        ;;

      # auCDtect and auCDtect with spectrogram arguments
      'a'|'A')
        # Skip as both auCDtect arguments were already specified
        [[ "${conflicting[@]}" == *'-a, -A'* ]] && continue

        # Add auCDtect to operation as it does not yet exist
        if [[ -z "${operations['_aucdtect']}" ]]; then
          [[ "$arg" == 'A' ]] && create_spectrogram='true'
          operations['_aucdtect']='Did Not Run'
          continue
        fi

        # '-A' was already specified and '-a' is the current argument
        if [[ "$arg" == 'a' && "$create_spectrogram" ]]; then
          conflicting+=( '-a, -A' )

        # '-a' was already specified and '-A' is the current argument
        elif [[ "$arg" == 'A' && ! "$create_spectrogram" ]]; then
          conflicting+=( '-a, -A' )
        fi
        ;;

      # ReplayGain and force ReplayGain arguments
      'g'|'G')
        # Skip as both ReplayGain arguments were already specified
        [[ "${conflicting[@]}" == *'-g, -G'* ]] && continue

        # Add ReplayGain to operation as it does not yet exist
        if [[ -z "${operations['_replaygain']}" ]]; then
          operations['_replaygain']='Did Not Run'
          [[ "$arg" == 'G' ]] && force_replaygain='true'
          continue
        fi

        # '-G' was already specified and '-g' is the current argument
        if [[ "$arg" == 'g' && "$force_replaygain" ]]; then
          conflicting+=( '-g, -G' )

        # '-g' was already specified and '-G' is the current argument
        elif [[ "$arg" == 'G' && ! "$force_replaygain" ]]; then
          conflicting+=( '-g, -G' )
        fi
        ;;
    esac
  done

  # Invalid parameters were specified
  if [[ "$invalid" ]]; then
    _error 'Invalid arguments specified:'
    _error "  ${cyan}${invalid}$reset"
  fi

  # Conflicting parameters were specified
  if (( ${#conflicting[@]} > 0 )); then
    _error 'Conflicting operations specified:'
    for option in "${conflicting[@]}"; do
      _error "  ${cyan}${option}$reset"
    done
  fi

  # Display help and exit if invalid or conflicting parameters exist
  if [[ "$invalid" ]] || (( ${#conflicting[@]} )); then
    _help
    exit 1
  fi

  # The last element passed in _should_ be the directory to process FLAC
  # files
  directory="${@: -1}"
  directory="${directory%/}"  # Remove ending slash

  # Ensure the directory exists
  if [[ ! -d "$directory" ]]; then
    _error 'Please specify a valid directory!'
    _help
    exit 1
  fi

  # Build $operations_to_run[@] which is an ordered array of operations
  # to run on the FLAC files/directories
  for op in "${ordered_operations[@]}"; do
    [[ "${operations[$op]}" ]] && operations_to_run+=( "$op" )
  done
}

#
# Check for missing programs required by this script
#
_check_missing_programs()
{
  local program
  local -a programs=( 'rm' 'mkdir' 'mkfifo' 'metaflac' 'flac' )
  local -a missing_programs

  for program in "${programs[@]}"; do
    type -P "$program" >/dev/null || missing_programs+=( "$program" )
  done

  if [[ -n "${operations['_aucdtect']}" ]]; then
    type -P auCDtect >/dev/null || missing_programs+=( 'auCDtect' )
  fi

  if [[ "$create_spectrogram" ]]; then
    type -P sox >/dev/null || missing_programs+=( 'sox' )
  fi

  if [[ "${missing_programs[@]}" ]]; then
    _error 'The following required programs were not found:'
    for program in "${missing_programs[@]}"; do
      _error "  ${cyan}${program}$reset"
    done

    _error
    _error 'Ensure these programs are installed and available in $PATH'

    exit 1
  fi
}

#
# Display the summary of operations chart
#
_summary()
{
  local op

  for op in "${operations_to_run[@]}"; do
    # Color summary message
    printf "$cyan"

    # Display summary message based on operation performed
    case "$op" in
      '_compress')
        printf '%-24s' "Compressing To Level $compression_level:"
        ;;
      '_md5check')       printf '%-24s' 'Verifying MD5:'       ;;
      '_test')           printf '%-24s' 'Testing:'             ;;
      '_aucdtect')       printf '%-24s' 'auCDtect Validation:' ;;
      '_replaygain')     printf '%-24s' 'Applying ReplayGain:' ;;
      '_retag')          printf '%-24s' 'Retagging:'           ;;
      '_extract_images') printf '%-24s' 'Extracting Images:'   ;;
      '_prune')          printf '%-24s' 'Pruning METADATA:'    ;;
    esac

    # Display status of operation
    case "${operations[$op]}" in
      'Completed')   printf "${green}%s${reset}\n" "${operations[$op]}"   ;;
      'Interrupted') printf "${yellow}%s${reset}\n" "${operations[$op]}"    ;;
      'Did Not Run') printf "${magenta}%s${reset}\n" "${operations[$op]}" ;;
    esac
  done

  printf '\033[?25h'            # Restore the cursor
  printf '\033[?7h'             # Restore terminal wrapping
  rm -f "$job_fifo"             # Remove temporary FIFO
  rm -f "$tmp_picture_blocks"   # Remove temporary 'metaflac' blocks
  rm -f "$issue_ticks"          # Remove temporary errors/issues file
}

#
# Run a given operation with a specified number of jobs
#
_run_parallel()
{
  local item            # FLAC file (or directory) to process
  local -i row num=0

  # Starting cursor row to display first item and operation progress
  row=$(($(_row) - 1))

  # Start as many operations as specified by the number of jobs
  for item in "${total_items[@]:0:$jobs}"; do
    ((row++, num++))
    "$operation" &
  done

  # Wait on operations if number of items is less than total jobs
  (( ${#total_items[@]} <= jobs )) && wait

  # Completion of an operation sends an integer (terminal row number)
  # and newline to a FIFO (job manager).
  #
  # After each newline is read from the FIFO, another item is processed
  while read -r row; do
    (( num >= ${#total_items[@]} )) && break  # Stop if no more FLACs
    item="${total_items[num++]}"              # Current item to process
    "$operation" &
  done <&3  # Read from FIFO

  # Wait on operations
  wait
}

#
# Apply ReplayGain tags to each FLAC file in a given directory.
# Conditionally skip FLAC files if ReplayGain tags are already set. If
# there are any errors, they are logged
#
_replaygain()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output error_msg
  local -a error_log files

  # Used to look for error messages and store wanted values
  local regex="^(${item}/.*): (ERROR:.*)"

  _print_item 'Applying ReplayGain'

  # If a user chooses not to force apply ReplayGain tags, then each file
  # is checked to ensure all ReplayGain tags are available, skipping the
  # directory of files if all ReplayGain tags are already set
  #
  # NOTE:
  #   All errors are ignored here as they will be caught during
  #   application ReplayGain tags
  if [[ -z "$force_replaygain" ]]; then
    files=( "$item"/*$flac_extension )  # Used for number of files

    # Obtain ReplayGain tags from all files in the current directory
    mapfile -n0 -t replaygain_tags < <(
      metaflac 2>/dev/null \
        --show-tag='REPLAYGAIN_REFERENCE_LOUDNESS' \
        --show-tag='REPLAYGAIN_TRACK_GAIN' \
        --show-tag='REPLAYGAIN_TRACK_PEAK' \
        --show-tag='REPLAYGAIN_ALBUM_GAIN' \
        --show-tag='REPLAYGAIN_ALBUM_PEAK' \
        "${files[@]}"
    )

    # All ReplayGain tags are set, so this directory can be skipped
    #
    # The total number of ReplayGain tags found on all files in the
    # current directory must equal the total number of files found
    # multiplied by 5 (the number of ReplayGain tags added to each file)
    if (( ${#replaygain_tags[@]} == ${#files[@]} * 5 )); then
      _print_item_skip
      printf >&3 "$row\n"  # Send complete to _run_parallel()
      return
    fi
  fi

  _print_item_half  # Metaflac doesn't display a percentage complete

  # Since this operation applies to multiple files in a given directory,
  # all error messages (per file) is stored into an array, then logged
  # to a file
  #
  # Metaflac only displays error messages to STDERR, nothing to STDOUT
  while IFS=$'\n' read -r output; do
    # Any output is an error message
    if [[ "$output" =~ $regex ]]; then
      error_msg="${BASH_REMATCH[1]} [ReplayGain] "  # Absolute filename

      # Error reading FLAC file (possibly fake), eg:
      #   ERROR: reading metadata, status = "FLAC__METADA ..."
      if [[ "${BASH_REMATCH[2]}" == *", status = "* ]]; then
        error_msg+="${BASH_REMATCH[2]%, status = *} "      # Error

      # Files with differing sample rates, or problems decoding, eg:
      #   ERROR: sample rate of 44100 Hz does not match ...
      #   ERROR: during analysis (decoding file)
      else
        error_msg+="${BASH_REMATCH[2]}"
      fi

      # All FLAC files are stored here to be logged
      error_log+=( "$error_msg" )
    fi
  done < <(
    metaflac 2>&1 \
      $metaflac_extra_options --add-replay-gain "$item"/*$flac_extension
  )

  # Log failures if there are any errors
  if [[ "${error_log[0]}" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s\n' "${error_log[@]}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    _print_item_ok
  fi

  # Send complete to _run_parallel()
  printf >&3 "$row\n"
}

#
# Compress FLAC files with user-defined compression, verifying
# integrity. Conditionally skip FLAC files if the 'COMPRESSION' tag
# exists for a given file and matches the compression level set in the
# user configuration file
#
_compress()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output previous error_msg warning_msg

  _print_item 'Compressing'

  # If a user chooses not to force compression, then each file is
  # checked for a 'COMPRESSION' tag that matches the compression level
  # set in the user configuration. If the 'COMPRESSION' tag exists and
  # matches what is set in the configuration, then this file is skipped
  #
  # NOTE:
  #   All errors are ignored here as they will be caught during
  #   compression
  if [[ -z "$force_compression" ]]; then
    file_compression="$(metaflac 2>/dev/null --show-tag='COMPRESSION' "$item")"

    # 'compression_level' is obtained from the configuration file, in
    # form of 'COMPRESSION=<value>'
    if (( ${file_compression##*=} == compression_level )); then
      _print_item_skip
      printf >&3 "$row\n"  # Send complete to _run_parallel()
      return
    fi
  fi

  # As indicated by '[FIRST]', '[SECOND]', '[THIRD]', '[FOURTH]', and
  # '[LAST]', this is the order each of the statements will evaluate to
  # 'true'.  '[FIRST]' may never evaluate to 'true' (if the FLAC file
  # fails to decode
  while IFS=$'\n' read -rd ' ' output; do
    # [LAST] Store error message
    if [[ "$error_msg" && -n "$output" ]]; then
      # End of error message
      [[ "$output" == 'state' || "$output" == '"flac"' ]] && break
      error_msg+=" $output"
      continue
    fi

    # [FOURTH] An error occurred, storing first word
    if [[ "$output" == 'ERROR:' && "$previous" == *"${base}:" ]]; then
      error_msg="$output"
      continue
    fi

    # [THIRD] Store rest of warning message
    if [[ "$warning_msg" && -n "$output" ]]; then
      # Stop if there is an error message and build that separately
      [[ "$output" == *'ERROR:' ]] && error_msg='ERROR:' && continue
      warning_msg+=" $output"
      continue
    fi

    # [SECOND] A warning occurred, storing first word
    #
    # NOTE:
    #   Due to 'read' using a space a delimiter, the WARNING message may
    #   have preceding text (word + newline)
    if [[ "$output" == *'WARNING:' ]]; then
      warning_msg='WARNING:'
      continue
    fi

    # [FIRST] FLAC compression percentage complete
    if [[ "$output" == *[[:digit:]]% ]]; then
      output="${output//$'\b'}"  # Remove all backspace characters

      # Remove beginning ratio string (from backspace characters)
      printf "\033[${row}H${yellow}%4s$reset" "${output#ratio=?.???}"
    fi

    # Used to validate previous output is an error and not a filename
    previous="$output"
  done < <(flac 2>&1 -f -"$compression_level" -V "$item")

  # Add warning message to error message for logging
  [[ "$warning_msg" ]] && error_msg="$warning_msg|$error_msg"

  # Log failures if there are any warnings and/or errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    error_msg="${error_msg%,}"          # Strip possible trailing comma
    error_msg="${error_msg/$'\n'Type}"  # Strip possible multiline error
    printf >> "$log_file" '%s [Compress] %s\n' "$item" "$error_msg"
    printf >> "$issue_ticks" '.'        # Add one tick to total issues

    # Send complete to _run_parallel()
    printf >&3 "$row\n"
    return
  fi

  # Add a 'COMPRESSION' tag to the current FLAC file, to indicate which
  # compression level was used when compressing
  #
  # NOTE:
  #   Errors are ignored as the FLAC file was verified during encoding
  metaflac 2>/dev/null \
    $metaflac_extra_options --set-tag="COMPRESSION=$compression_level" "$item"
  _print_item_ok

  # Send complete to _run_parallel()
  printf >&3 "$row\n"
}

#
# Tests current FLAC file integrity, reading all output, displaying the
# current percentage complete. If there is an error that error is logged
#
_test()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output previous error_msg

  # Basename of FLAC, splitting on whitespace since the 'read' below
  # splits on whitespace
  local base="${item##*[ /]}"

  _print_item 'Testing'

  # As indicated by '[FIRST]', '[SECOND]', and '[LAST]', this is the
  # order each of the statements will evaluate to 'true'. '[FIRST]' may
  # never evaluate to 'true' (if the FLAC file fails to decode)
  while IFS=$'\n' read -rd ' ' output; do
    # [LAST] Store error message
    if [[ "$error_msg" && -n "$output" ]]; then
      [[ "$output" == 'state' ]] && break  # End of error message
      error_msg+=" $output"
      continue
    fi

    # [SECOND] An error occurred, storing first word
    if [[ "$output" == 'ERROR' && "$previous" == *"${base}:" ]]; then
      error_msg="$output"
      continue
    fi

    # [FIRST] FLAC testing percentage complete
    if [[ "$output" == *[[:digit:]]% ]]; then
      printf "\033[${row}H${yellow}%4s$reset" "$output"
    fi

    # Used to validate previous output is an error and not a filename
    previous="$output"
  done < <(flac 2>&1 -t "$item")

  # Log failures if there are any errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [Test] %s\n' "$item" "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    _print_item_ok
  fi

  # Send complete to _run_parallel()
  printf >&3 "$row\n"
}

#
# Test FLAC validity with auCDtect
#
# NOTE:
#   While not officially supported, should a user have a dynamically
#   linked auCDtect binary, 'MALLOC_CHECK_' will to be set to '0', eg:
#
#     MALLOC_CHECK_='0' auCDtect <rest_of_options>
#
_aucdtect()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local item_wav output previous error_msg aucdtect_stdout aucdtect_stderr \
    spectrogram
  local -a bits_mastering

  # Used to look for error messages and file status in auCDtect which is
  # captured via STDOUT
  #
  # Example STDOUT from auCDtect (error message):
  #   auCDtect: CD records authenticity detector, version 0.8
  #   Copyright (c) 2004 Oleg Berngardt. All rights reserved.
  #   Copyright (c) 2004 Alexander Djourik. All rights reserved.
  #   error:  file format     is not supported
  #
  # Example STDOUT from auCDtect (file status):
  #   auCDtect: CD records authenticity detector, version 0.8
  #   Copyright (c) 2004 Oleg Berngardt. All rights reserved.
  #   Copyright (c) 2004 Alexander Djourik. All rights reserved.
  #   ------------------------------------------------------------
  #   Processing file:        [01 - The Manifesto.wav]
  #
  #   ------------------------------------------------------------
  #   This track looks like CDDA with probability 85%
  #
  # Example regex capture groups obtained:
  #
  # Error messages:
  #   error:  can     not     open file <WAV_FILE>
  #   error:  file format     is not supported
  #
  # Successful operations:
  #   This track looks like CDDA with probability 100%
  #   This track looks like CDDA with probability 49%
  #   This track looks like MPEG with probability 100%
  #   This track looks like MPEG with probability 92%
  #   Could not qualify the source of this track.
  local regex=$'(error:.*)|Processing file.*--------.*\n(.*)$'

  _print_item 'auCDtect'

  # Get the bit depth and MASTERING tag of a FLAC file. Errors will be
  # caught during decoding. Indices are:
  #   bits_mastering[0] = bit depth (eg: 16)
  #   bits_mastering[1] = MASTERING tag and value (eg: MASTERING=Lossy)
  mapfile -n2 -t bits_mastering < <(
    metaflac 2>/dev/null --show-bps --show-tag='MASTERING' "$item"
  )

  # auCDtect does not support a bit depth greater than 16 (CD quality
  # only), skipping file
  #
  # NOTE:
  #   A default value of 0 is specified in the event the bit depth could
  #   not be obtained. Errors will be caught during decoding
  if (( ${bits_mastering[0]:-0} > 16 )); then
    _print_item_skip
    printf >&3 "$row\n"  # Send complete to _run_parallel()
    return
  fi

  # Skip FLAC file if MASTERING=Lossy is set and the 'skip_lossy'
  # configuration option is 'true'
  if [[
    "${bits_mastering[1]#*=}" == 'Lossy'
    && "$skip_lossy" == 'true'
  ]]; then
    _print_item_skip
    printf >&3 "$row\n"  # Send complete to _run_parallel()
    return
  fi

  # The WAV file to be created from current FLAC file
  item_wav="${item%${flac_extension}}_redoflacs_$$.wav"

  _print_item 'Decoding'

  # As indicated by '[FIRST]', '[SECOND]', and '[LAST]', this is the
  # order each of the statements will evaluate to 'true'. '[FIRST]' may
  # never evaluate to 'true' (if the FLAC file fails to decode)
  while IFS=$'\n' read -rd ' ' output; do
    # [LAST] Store error message
    if [[ "$error_msg" && -n "$output" ]]; then
      [[ "$output" == 'state' ]] && break  # End of error message
      error_msg+=" $output"
      continue
    fi

    # [SECOND] An error occurred, storing first word
    if [[ "$output" == 'ERROR' && "$previous" == *"${base}:" ]]; then
      error_msg="$output"
      continue
    fi

    # [FIRST] FLAC decoding percentage complete
    if [[ "$output" == *[[:digit:]]% ]]; then
      output="${output//$'\b'}"  # Remove all backspace characters

      # Remove beginning 'complete' string (from backspace characters)
      printf "\033[${row}H${yellow}%4s$reset" "${output#complete}"
    fi

    # Used to validate previous output is an error and not a filename
    previous="$output"
  done < <(flac 2>&1 -d "$item" -o "$item_wav")

  # Log failures if there are any errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [%s] %s\n' "$item" 'auCDtect' "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  else
    _print_item_ok
  fi

  # Runs auCDtect with medium accuracy setting (for speed):
  #   STDOUT: auCDtect STDOUT captured to be parsed
  #   STDERR: auCDtect progress percentage completed sent to FD4
  _print_item 'auCDtect:Fast'
  exec 4>&1
  aucdtect_stdout="$(
    MALLOC_CHECK_='0' auCDtect -m20 "$item_wav" 2> >(
      while IFS=$'\n' read -rd $'\r' aucdtect_stderr; do
        aucdtect_stderr="${aucdtect_stderr##*[}"
        printf >&4 "\033[${row}H${yellow}%4s$reset" "${aucdtect_stderr%]}"
      done
    )
  )"
  exec 4>&-

  # Looks for error messages and file status from auCDtect
  #   BASH_REMATCH[1]: auCDtect error messages
  #   BASH_REMATCH[2]: auCDtect file status
  [[ "$aucdtect_stdout" =~ $regex ]]

  # Log failures if there are any errors
  if [[ "${BASH_REMATCH[1]}" ]]; then
    _print_item_fail
    printf >> "$log_file" \
      '%s [%s] %s\n' "$item" 'auCDtect' "${BASH_REMATCH[1]}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
    rm "$item_wav"                # Remove temporary WAV file
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return

  # auCDtect reports CDDA of 100%, continue with next item
  elif [[ "${BASH_REMATCH[2]}" == *'CDDA'*'100%'* ]]; then
    _print_item_ok
    rm "$item_wav"                # Remove temporary WAV file
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  fi

  # Current item is not CDDA of 100%, auCDtect is run with highest
  # accuracy setting:
  #   STDOUT: auCDtect STDOUT captured to be parsed
  #   STDERR: auCDtect progress percentage completed sent to FD4
  _print_item 'auCDtect:Slow'
  exec 4>&1
  aucdtect_stdout="$(
    MALLOC_CHECK_='0' auCDtect -m0 "$item_wav" 2> >(
      while IFS=$'\n' read -rd $'\r' aucdtect_stderr; do
        aucdtect_stderr="${aucdtect_stderr##*[}"
        printf >&4 "\033[${row}H${yellow}%4s$reset" "${aucdtect_stderr%]}"
      done
    )
  )"
  exec 4>&-

  # Looks for error messages and file status from auCDtect
  #   BASH_REMATCH[1]: auCDtect error messages
  #   BASH_REMATCH[2]: auCDtect file status
  [[ "$aucdtect_stdout" =~ $regex ]]

  # Log failures if there are any errors
  if [[ "${BASH_REMATCH[1]}" ]]; then
    _print_item_fail
    printf >> "$log_file" \
      '%s [%s] %s\n' "$item" 'auCDtect' "${BASH_REMATCH[1]}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
    rm "$item_wav"                # Remove temporary WAV file
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  fi

  # auCDtect reports CDDA of 100%, continue with next item
  if [[ "${BASH_REMATCH[2]}" == *'CDDA'*'100%'* ]]; then
    _print_item_ok
    rm "$item_wav"                # Remove temporary WAV file
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  fi

  # Log failure if not CDDA with 100% and no spectrogram is requested
  if [[
    "${BASH_REMATCH[2]}" != *'CDDA'*'100%'*
    && "$create_spectrogram" != 'true'
  ]]; then
    _print_item_check
    printf >> "$log_file" \
      '%s [%s] %s\n' "$item" 'auCDtect' "${BASH_REMATCH[2]}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
    rm "$item_wav"                # Remove temporary WAV file
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  fi

  # User requested a spectrogram, SoX is run to generate a spectrogram
  # in the location as the current item or a user-defined location
  _print_item 'Spectrogram'

  # Default location for spectrogram, eg:
  #   /path/to/file.flac.spec.png.0
  #
  # User defined (eg: /tmp):
  #   /user/configured/path/to/file.flac.spec.png.0
  spectrogram="${spectrogram_location:-${item%/*}}/${item##*/}.spec.png.0"

  # Ensure we don't clobber the spectrogram, eg:
  #   /path/to/file.flac.spec.png.0 ->
  #   /path/to/file.flac.spec.png.1 ->
  until [[ ! -f "$spectrogram" ]]; do
    spectrogram="${spectrogram%.*}.$((${spectrogram##*.} + 1))"
  done

  # SoX display progress percentage on STDERR as well as any error
  # messages. Example output:
  #
  # Error messages:
  #   sox FAIL formats: can't open input file `file.wav': WAVE: RIF<...>
  #   sox FAIL formats: can't open input file `file.flacd': No such<...>
  #
  # NOTE:
  #  The '-n1000' is to force 'read' to grab the SoX error if there are
  #  any error messages, otherwise the percentage complete is read
  while IFS=$'\n' read -rd '%' -n1000 output; do
    # Strip from leading string until percentage complete
    output="${output##*In:}"

    # Strip floating point from output
    printf "\033[${row}H${yellow}%4s${reset}" "${output%%.*}%"
  done < <(
    sox 2>&1 "$item" -S -n spectrogram -o "$spectrogram" -t "$item" \
      -c '' -p 1 -z 90 -Z 0 -q 249 -w Hann -x 1800 -y 513
  )

  # Log failures if there are any errors from SoX
  if [[ "$output" == 'sox FAIL'* ]]; then
    _print_item_fail
    printf >> "$log_file" \
      '%s [%s] %s\n' "$item" 'auCDtect:Spectrogram' "$output"

  # Log auCDtect status for item as well as generated spectrogram
  else
    _print_item_check
    printf >> "$log_file" \
      '%s [%s] %s (%s)\n' \
      "$item" 'auCDtect:Spectrogram' "${BASH_REMATCH[2]}" "$spectrogram"
  fi

  printf >> "$issue_ticks" '.'  # Add one tick to total issues
  rm "$item_wav"                # Remove temporary WAV file
  printf >&3 "$row\n"           # Send complete to _run_parallel()
}

#
# Check for a valid MD5 checksum in FLAC file
#
_md5check()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output error_msg md5sum

  _print_item 'Verifying MD5'

  # Metaflac will display the MD5 checksum or an error (on one line).
  # These values are captured and logged, appropriately
  while IFS=$'\n' read -r output; do
    # Error reading FLAC file (possibly fake), eg:
    #   fake/fake.flac: ERROR: reading metadata, status = "FLAC ..."
    if [[ "$output" == *'ERROR'* ]]; then
      error_msg="${output%, status = *}"      # Strip status
      error_msg="ERROR${error_msg#*: ERROR}"  # Strip filename
      break                                   # Stop reading lines
    fi

    # This is the MD5 checksum
    md5sum="$output"
  done < <(metaflac 2>&1 --show-md5sum "$item")

  # Log failures if there are any errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [MD5check] %s\n' "$item" "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues

  # Possible valid FLAC, but MD5 signature is unset in STREAMINFO block
  elif [[ "$md5sum" == '00000000000000000000000000000000' ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [MD5check] %s\n' "$item" \
      'ERROR: Unset MD5 signature (00000000000000000000000000000000)'
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    _print_item_ok
  fi

  # Send complete to _run_parallel()
  printf >&3 "$row\n"
}

#
# Looks for the tags specified in the configuration file, stripping all
# other tags from a given FLAC file, and logging any tags which are
# missing
#
# Process substitution when extracting tags is used to ensure trailing
# newlines are not stripped
#
_retag()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output error_msg line extracted_tag key empty_tag tag missing_tags_str
  local -i index='-1'
  local -a missing_tags found_tags tags

  _print_item 'Retagging'

  # Extracts the first tag from the list of tags to keep and does error
  # handling on this operation. Other extracted tags are processeed in
  # the following loop after the error handling
  #
  # Metaflac will display errors on one line. These are handled first
  # with the tag value obtained last (if no failures)
  while IFS=$'\n' read -r output; do
    # Error reading FLAC file (possibly fake), eg:
    #   fake/fake.flac: ERROR: reading metadata, status = "FLAC ..."
    if [[ "$output" == *'ERROR'* ]]; then
      error_msg="${output%, status = *}"      # Strip status
      error_msg="ERROR${error_msg#*: ERROR}"  # Strip filename
      break                                   # Stop reading lines
    fi

    # This is the extracted tag (could be empty or multiple lines)
    if [[ "$extracted_tag" ]]; then
      extracted_tag+=$'\n'"$output"
    else
      extracted_tag+="$output"
    fi
  done < <(metaflac 2>&1 --show-tag="${tags_to_keep[0]}" "$item")

  # Log failures if there are any errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [Retag] %s\n' "$item" "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues

    # Send complete to _run_parallel()
    printf >&3 "$row\n"
    return
  fi

  # Look for each of the tags to keep in the current FLAC flac,
  # separating each of the tags as separate indices in an array. If
  # there are any missing tags, these are stored as well
  for key in "${!tags_to_keep[@]}"; do
    # The first tag (index=0) was already obtained during error checking
    if (( key != 0 )); then
      IFS='' read -rd '' extracted_tag < <(
        metaflac 2>&1 --show-tag="${tags_to_keep[key]}" "$item"
      )

      # Strips trailing newline due to the process substitution
      # preserving trailing newlines
      extracted_tag="${extracted_tag%$'\n'}"
    fi

    # The tag doesn't exist in the current item
    if [[ -z "$extracted_tag" ]]; then
      missing_tags+=( "${tags_to_keep[key]}" )
      continue
    fi

    # Processes the extracted tag, looking for multiple tags of the same
    # type as well and handling multiple line values for a given tag
    # value. For any valid tags, each are stored as a separate index in
    # an array
    #
    # For any stored tag, the tag field is converted to uppercase and
    # the tag values are normalized (whitespace, zero-prefixed, etc)
    while IFS=$'\n' read -r line; do
      # Tag exists but the value is empty. This may be a missing tag
      if [[ "${line^^}" == "${tags_to_keep[key]^^}=" ]]; then
        # If a previous line was an empty tag field, this means the
        # previous tag was, in fact, empty
        [[ "$empty_tag" ]] && missing_tags+=( "$empty_tag" )

        # Sets the tag field as empty and is used to check any
        # additional lines which may be part of this tag
        empty_tag="${tags_to_keep[key]^^}"
        continue

      # Tag exists and has a value (first line value only)
      elif [[ "${line^^}" == "${tags_to_keep[key]^^}="* ]]; then
        # Strip leading/trailing whitespace
        IFS=$' \t\n' read -r line <<< "${line#*=}"

        # Convert TRACKNUMBER and TRACKTOTAL to zero-prefixed numbers if
        # the 'prepend_zero' configuration option is 'true'
        if [[
          (
            "${tags_to_keep[key]}" == 'TRACKNUMBER'
            || "${tags_to_keep[key]}" == 'TRACKTOTAL'
          )
          && "$prepend_zero" == 'true'
        ]]; then
          # Only modify value if the value is an integer
          if [[ "$line" =~ ^[[:digit:]]+$ ]]; then
            printf -v line '%02d' $((10#$line))
          fi
        fi

        # Ensure tag field is uppercase and array index, incremented.
        # The index starts at -1, so is pre-incremented to 0 before
        # setting a value
        found_tags[++index]="${tags_to_keep[key]^^}=$line"
        continue
      fi

      # Strip leading/trailing whitespace
      IFS=$' \t\n' read -r line <<< "$line"

      # If this variable is set, it means the previous line was an empty
      # tag field but since this point is reached, the current line is a
      # part of the tag so the previous line is a valid tag. The tag is
      # considered NOT empty and is saved with this line as part of the
      # tag's value. An example tag where this could happen:
      #
      #    LYRICS=
      #
      #    This is a line for the above 'LYRICS' tag field.
      #    This is another line which is a part of the same tag.
      #
      # The first line (LYRICS=) is originally considered an empty tag,
      # but the following lines are processed and added to the tag
      # making this tag valid and non-empty
      if [[ "$empty_tag" ]]; then
        found_tags[++index]="${empty_tag}="$'\n'"$line"
        empty_tag='' # Reset as the tag is considered valid
      else
        # Another value (separate line) for the current tag field
        found_tags[index]+=$'\n'"${line}"
      fi
    done <<< "$extracted_tag"
  done

  # Runs through the missing tags and only stores the tag as missing if
  # there are no other tags found which match the tag field. This could
  # happen, if there are multiple tags of the same tag field and some
  # are empty, but at least one is valid, eg:
  #
  #   DATE=
  #   DATE=
  #   DATE=2001
  #
  # The DATE tag is considered missing, but when processed below, would
  # be considered found and valid (the other empty DATE tags will be
  # removed)
  for tag in "${!missing_tags[@]}"; do
    # Looks through all the valid and normalized tags found
    for valid_tag in "${found_tags[@]}"; do
      # Matched a tag and value for a missing tag, no longer missing
      if [[ "$valid_tag" == "${missing_tags[tag]}="* ]]; then
        unset -v missing_tags[tag]
        break
      fi
    done
  done

  # Removes all tags from the current FLAC file and sets each found tag
  # all in one operation. A single operation prevents SIGINT from
  # leaving the current FLAC file without any tags
  metaflac >/dev/null 2>&1 $metaflac_extra_options \
    --remove-all-tags "${found_tags[@]/#/--set-tag=}" "$item"

  # Logs missing tags, if any were found
  if [[ "${missing_tags[@]}" ]]; then
    _print_item_check

    # Generates a comma-separated list of missing tags to be logged.
    # Ensures spaces in tag fields are properly handled
    for tag in "${missing_tags[@]}"; do
      if [[ "$missing_tags_str" ]]; then
        missing_tags_str+=", $tag"
      else
        missing_tags_str+="$tag"
      fi
    done

    printf >> "$log_file" \
      '%s [Retag] Missing tags: %s\n' "$item" "$missing_tags_str"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    _print_item_ok
  fi

  # Send complete to _run_parallel()
  printf >&3  "$row\n"
}

#
# Extact embedded artwork from a given FLAC
#
_extract_images()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local -a artwork
  local error_msg block_id art_id art_description mime img
  local blocks="/tmp/redoflacs_picture_blocks.$BASHPID"

  # Ensure we don't clobber the temporary PICTURE blocks file, eg:
  #   /tmp/redoflacs_picture_blocks.0 -> /tmp/redoflacs_picture_blocks.1
  until [[ ! -f "$blocks" ]]; do
    blocks="${blocks%.*}.$((${blocks##*.} + 1))"
  done

  _print_item 'Extracting Images'

  # Retrieve PICTURE blocks from current item, to a temporary file
  error_msg="$(metaflac 2>&1 >"$blocks" --list --block-type=PICTURE "$item")"

  # Log FLAC failure
  if [[ -n "$error_msg" ]]; then
    error_msg="${error_msg%, status = *}"       # Strip end of error msg
    error_msg="ERROR ${error_msg##*: ERROR: }"  # Strip filename

    _print_item_fail
    printf >> "$log_file" '%s [ExtractArtwork] %s\n' "$item" "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
    rm -f "$blocks"
    printf >&3 "$row\n"           # Send complete to _run_parallel()
    return
  fi

  # Skip if there were no PICTURE blocks found in current FLAC
  if [[ ! -s "$blocks" ]]; then
    _print_item_skip
    rm -f "$blocks"
    printf >&3 "$row\n"  # Send complete to _run_parallel()
    return
  fi

  _print_item_half  # Metaflac doesn't display a percentage complete

  # Store the values which can identify each image (in each PICTURE
  # block) to be used during image extraction.  The values needed are:
  #   'METADATA block #<num>'           -> $block_id
  #   '  type: <num> (<description>)'   -> $art_id AND $art_description
  #   '  MIME type: image/jpeg'         -> $mime
  #
  # NOTE:
  #   Reading the PICTURE block from a temporary file is much faster
  #   than reading from process substitution (there can be many PICTURE
  #   blocks in a single FLAC file and each image could be very large)
  while IFS=$'\n' read -r; do
    # Skip all the unnecessary information
    [[ "$REPLY" != 'METADATA'* && "$REPLY" != '  '[tM]* ]] && continue

    if [[ "$REPLY" == 'METADATA'* ]]; then
      block_id="${REPLY##*#}"
      continue
    fi

    # Ensure we don't use: 'type: 6 (PICTURE)'
    if [[ "$REPLY" == '  type: '[^6]* ]]; then
      IFS=' ' read -r _ art_id art_description <<< "${REPLY//\//-}"
      art_description="${art_description//[()]}"  # Strip parenthesis
      art_description="${art_description// /_}"   # Spaces underscores
      continue

    # Done with a PICTURE block; the values can be stored and the
    # variables reset
    elif [[ "$REPLY" == '  MIME'* ]]; then
      mime="${REPLY##*/}"     # Eg: 'MIME type: image/jpeg' -> 'jpeg'
      mime="${mime/jpeg/jpg}" # Eg: 'jpeg'                  -> 'jpg'

      # Eg: '4:3-Cover_front.jpg'
      artwork+=( "${block_id}:${art_id}-${art_description}.${mime}" )
      unset -v block_id art_id art_description mime
    fi
  done < "$blocks"
  rm -f "$blocks"

  # Continue only if there was artwork to be extracted
  if [[ -z "${artwork[@]}" ]]; then
    printf >&3 "$row\n"  # Send complete to _run_parallel()
    return
  fi

  # Determine where to put extracted artwork by checking user config
  if [[ -n "$artwork_location" ]]; then
    # /user/configured/path/to/artwork/file.flac.art.0
    artwork_location="${artwork_location%/}/${item##*/}.art.0"
  else
    # /path/to/file.flac.art.0
    artwork_location="${item}.art.0"
  fi

  # Ensure we don't clobber the artwork directory, eg:
  #   /path/to/file.flac.art.0 -> /path/to/file.flac.art.1
  #
  # Or if the user configured an artwork directory from the
  # configuration file:
  #   /user/configured/path/to/artwork/file.flac.art.0 ->
  #   /user/configured/path/to/artwork/file.flac.art.1
  until [[ ! -d "$artwork_location" ]]; do
    artwork_location="${artwork_location%.*}.$((${artwork_location##*.} + 1))"
  done
  mkdir -p "$artwork_location"

  # Performs artwork extraction on the current item. Each array value:
  #   '<block_id>:<art_id>-<art_description>.<mime>
  #
  # Which looks like:
  #   '4:3-Cover_front.jpg'
  for value in "${artwork[@]}"; do
    # Eg: '/path/to/file.flac.art.0/3-Cover_front.jpg.0'
    img="${artwork_location}/${value#*:}.0"
    block_id="${value%%:*}"  # Eg: '4:3-Cover_front.jpg' -> '4'

    # Ensure we don't clobber the extracted image, eg:
    #   /path/to/file.flac.art.0/3-Cover_front.jpg.0 ->
    #   /path/to/file.flac.art.0/3-Cover_front.jpg.1
    until [[ ! -f "$img" ]]; do
      img="${img%.*}.$((${img##*.} + 1))"
    done

    # Extracts each image by METADATA block number
    metaflac --block-number="$block_id" --export-picture-to="$img" "$item"
  done

  _print_item_ok
  printf >&3 "$row\n"  # Send complete to _run_parallel()
}

#
# Prune user configurable FLAC metadata from FLAC files
#
_prune()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT
  local output error_msg

  _print_item 'Pruning'
  _print_item_half  # Metaflac doesn't display a percentage complete

  # Remove all information but STREAMINFO,VORBIS_COMMENTs, and
  # possibly METADATA_BLOCK_PICTURE
  while IFS=$'\n' read -r output; do
    # Error reading FLAC file (possibly fake), eg:
    #   fake/fake.flac: ERROR: reading metadata, status = "FLAC ..."
    if [[ "$output" == *'ERROR'* ]]; then
      error_msg="${output%, status = *}"      # Strip status
      error_msg="ERROR${error_msg#*: ERROR}"  # Strip filename
      break                                   # Stop reading lines
    fi
  done < <(
    metaflac 2>&1 \
      $metaflac_extra_options --remove --dont-use-padding \
      --except-block-type="$dont_prune_flac_metadata" "$item"
  )

  # Log failures if there are any errors
  if [[ "$error_msg" ]]; then
    _print_item_fail
    printf >> "$log_file" '%s [Prune] %s\n' "$item" "$error_msg"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    _print_item_ok
  fi

  # Send complete to _run_parallel()
  printf >&3 "$row\n"
}

###############################  SETUP  ################################

#
# Make sure we are running BASH 4 or greater
#
if (( ${BASH_VERSINFO[0]} < 4 )); then
  _error "You must be running ${cyan}BASH 4$reset or greater to use"
  _error 'this program! Current version:'
  _error "  ${cyan}${BASH_VERSION}$reset"
  exit 1
fi

#
# Ensure Cygwin is not used to run this script
#
if [[ "$(uname -o)" == 'Cygwin' ]]; then
  _error "This version of ${cyan}redoflacs$reset is meant to be run under"
  _error "UNIX/Linux. Please use the ${cyan}Cygwin$reset version located here:"
  _error "  ${cyan}https://github.com/sirjaren/redoflacsw$reset"
  exit 1
fi

#
# BASH 4: Used to recursively find (glob) FLAC files (eg, /**/*.flac)
#
shopt -s globstar 2>/dev/null

script_version='0.31_pre'           # Redoflacs version
flac_extension='.[Ff][Ll][Aa][Cc]'  # FLAC extension (case-insensitive)

declare -i script_revision='4'      # Script user configuration revision

# For colored output
reset=$'\033[0m'
red=$'\033[31m'
green=$'\033[32m'
yellow=$'\033[33m'
blue=$'\033[34m'
magenta=$'\033[35m'
cyan=$'\033[36m'

#########################  PRE-SCRIPT CHECKS  ##########################

#
# System or user configuration
#
if (( EUID == 0 )); then
  config_file='/etc/redoflacs.conf'
else
  config_file="${HOME}/.config/redoflacs/config"
fi

#
# Check if system-wide configuration doesn't exist
#
if [[ ! -f "$config_file" ]]; then
  mkdir -p "${config_file%/*}"  # Create directory if it doesn't exist
  _create_config                # Create configuration file

  _info 'A configuration file has been created here:\n'
  _info "${cyan}${config_file}${reset}\n\n"

  _info 'Please review it before running this program.\n'

  exit 0
else
  _parse_config
fi

#
# Generate log file location
#
# Ensure we don't overwrite an existing log file
pid="$$"
log_file="${error_log}/redoflacs_$pid.log"
until [[ ! -f "$log_file" ]]; do
  log_file="${error_log}/redoflacs_log_$((++pid)).log"
done

#
# Process/validate script positional parameters. This function provides
# variables which are used by later functions/operations (based on
# whether certain operations are specified)
#
_process_arguments "${@}"

#
# Check for missing programs required by this script
#
_check_missing_programs

# Make sure the artwork location is valid, if the operation is called
if [[ "${operations[9]}" == 'extract_images' ]]; then
  # Check if artwork_location is user-defined
  if [[ -n "${artwork_location}" ]]; then
    # Put extracted artwork in user-defined location, testing to make
    # sure the directory exists
    if [[ ! -d "${artwork_location}" ]]; then
      _error "${cyan}${artwork_location%/}${reset} doesn't exist!\n"
      _error 'Please set a valid directory in the configuration file!\n'
      exit 1
    fi
  fi
fi

# If '-A, --aucdtect-spectrogram' was called, make sure
# $spectrogram_location is valid
if [[ "${create_spectrogram}" == 'true' ]]; then
  # Check if spectrogram_location is user-defined
  if [[ -n "${spectrogram_location}" ]]; then
    # Put spectrograms in user-defined location, testing to make sure
    # the directory exists
    if [[ ! -d "${spectrogram_location}" ]]; then
      _error "${cyan}${spectrogram_location}${reset} doesn't exist!\n"
      _error 'Please set a valid directory in the configuration file!\n'
      exit 1
    fi
  fi
fi

#
# Dynamically sets the number of jobs to use if the user did not specify
# them via '-j[N]', defaulting to two (2) jobs if unable find the number
# of online CPU's to determine the number of jobs
#
jobs="${jobs:-"$(command -p nproc 2>/dev/null)"}"
jobs="${jobs:-"$(command -p getconf _NPROCESSORS_ONLN 2>/dev/null)"}"
jobs="${jobs:-"$(command -p sysctl -n hw.ncpu 2>/dev/null)"}"
jobs="${jobs:-2}"

###############################  MAIN  #################################

export LANG=C
export LC_ALL=C

printf '\033[?25l'                          # Hide cursor
printf '\033[?7l'                           # Disable terminal wrapping

_check_config_version                       # Script config version

job_fifo="/tmp/redoflacs_fifo_$$"           # Job manager FIFO
issue_ticks="/tmp/redoflacs_issue_file_$$"  # Issues/Errors file

#
# Obtain the total number of lines and columns available in the terminal
# by sending the following control sequences to the terminal driver:
#
#   CSI s                # Save cursor position
#   CSI 999999 999999 H  # Move cursor to the end of the last row
#   CSI 6 n              # Query cursor position
#   CSI u                # Restore cursor position
#
# 'CSI 6 n' reports/returns the cursor position/terminal size as:
#   CSI height ; width R
#
# An example:
#   '\033[80;23R'
#
# Send CSI escape to (and read from) STDERR to not pollute STDIN
IFS='[;' \
  read -rsu2 -d'R' -p $'\033[s\033[999999;999999H\033[6n\033[u' _ lines columns

# The maximum length is one higher than the display width as output is
# displayed using escape sequences, making shell arithmetic inclusive
# off by one
if ((columns < 80)); then
  readonly MAX_LENGTH="$((++columns))"
else
  readonly MAX_LENGTH='81'
fi

#
# Clear echoed ^C to terminal and restore cursor visibilty on SIGINT
#
trap "printf '\033[$(( $(_row) + 1 ));0H\033[0K\033[?25h'; exit 130" SIGINT

# _retag(): Display a countdown
[[ "${operations[@]}" == *'_retag'* ]] && _countdown_metadata

#
# Obtain the total FLAC files to process (files and/or directories)
#
# NOTE:
#   The array of FLAC files/directories contain absolute pathnames which
#   allows logging to determine where each item resides
#
_info 'Looking for FLAC files to process...'
pushd "$directory" >/dev/null
total_items=( "${PWD}"/**/*${flac_extension} )
popd >/dev/null

# If there were no FLAC files found, the glob will exist as index 0, eg:
#   /path/to/files/**/*.[Ff][Ll][Aa][Cc]
if [[ ! -f "${total_items[0]}" ]]; then
  _error 'There were no FLAC files found!'
  printf '\033[?25h'   # Restore cursor
  exit 1
fi

# Loop through the various operations to run
for operation in "${operations_to_run[@]}"; do
  case "$operation" in
    '_replaygain')
      total_items_backup=( "${total_items[@]}" )  # Total FLACs backup
      for dir in "${total_items[@]%/*}"; do
        previous="$current"
        current="$dir"
        [[ "$previous" != "$current" ]] && total_dirs+=( "$current" )
      done
      total_items=( "${total_dirs[@]}" )          # Process directories
    ;;
    '_prune')
      # Set which FLAC metadata BLOCKS to remove
      if [[ "${remove_artwork}" == 'true' ]]; then
        # Remove PICTURE block
        dont_prune_flac_metadata='STREAMINFO,VORBIS_COMMENT'
      else
        # Do not remove PICTURE block
        dont_prune_flac_metadata='STREAMINFO,PICTURE,VORBIS_COMMENT'
      fi
    ;;
  esac

  _message "$operation"  # Display title message of operation
  _scroll_terminal       # Scroll terminal up (if needed)

  # Clear job manager file descriptor (tied to FIFO)
  exec 3<&- 3>&-       # Close file descriptor
  rm -f "$job_fifo"    # Remove FIFO if it exists
  mkfifo "$job_fifo"   # Create FIFO
  exec 3<>"$job_fifo"  # Open file descriptor read/write

  if (( ${#total_items[@]} < jobs )); then
    # Set row to place cursor after completing an operation and/or trap
    #
    # If the items to process are less than the number of jobs, add the
    # number of items to the current row position, else add the number
    # of jobs to run
    items_processed="${#total_items[@]}"
  else
    items_processed="${jobs}"
  fi

  post_row=$(( $(_row) + items_processed ))  # Operation row position

  trap '_trap_sigint "${operation}"' SIGINT  # Clean exit on SIGINT
  _run_parallel "$operation"                 # Run operation with jobs

  for (( i=1; i<=items_processed; i++)); do
    # Clear all the operation lines by moving up each line and clearing
    # it, until we are just below the operation's title message
    printf "\033[$(( post_row - i))H%${columns}s" ''
  done

  # Display number of finished items minus items with issues
  _message "${operation}" "$(( iteration - $(_num_issues) ))"

  # Update operation status to complete
  operations["$operation"]='Completed'

  if [[ -f "${log_file}" ]]; then
    _message_log_exists "${operation}"  # Print out log exists to STDERR
    _summary                            # Display Summary Of Operations
    exit 1
  fi

  # Restore the items to process from directories to FLACs
  [[ "${operation}" == 'replaygain_'*'apply' ]] && total_items=( "${total_items_backup[@]}" )
done

_summary  # Display Summary Of Operations
